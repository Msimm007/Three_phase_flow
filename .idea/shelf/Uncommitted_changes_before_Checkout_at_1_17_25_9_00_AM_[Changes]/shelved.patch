Index: ThreePhase.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\t#include <deal.II/base/quadrature_lib.h>\r\n#include <deal.II/lac/dynamic_sparsity_pattern.h>\r\n#include <deal.II/lac/sparse_matrix.h>\r\n#include <deal.II/distributed/shared_tria.h>\r\n#include <deal.II/grid/grid_in.h>\r\n#include <deal.II/grid/grid_out.h>\r\n#include <deal.II/grid/grid_refinement.h>\r\n#include <deal.II/grid/tria_iterator.h>\r\n#include <deal.II/fe/fe_values.h>\r\n#include <deal.II/dofs/dof_handler.h>\r\n#include <deal.II/numerics/vector_tools.h>\r\n#include <deal.II/dofs/dof_tools.h>\r\n#include <deal.II/numerics/data_out.h>\r\n#include <deal.II/fe/mapping_q1.h>\r\n#include <deal.II/fe/fe_dgq.h>\r\n#include <deal.II/lac/precondition_block.h>\r\n#include <deal.II/lac/affine_constraints.h>\r\n#include <deal.II/base/tensor_product_polynomials.h>\r\n#include <deal.II/fe/fe_raviart_thomas.h>\r\n\r\n#include <deal.II/base/conditional_ostream.h>\r\n#include <deal.II/base/mpi.h>\r\n\r\n#include <deal.II/base/timer.h>\r\n\r\n#include <deal.II/grid/grid_tools.h>\r\n\r\n#include <deal.II/base/parameter_handler.h>\r\n\r\n\r\n#include \"RT_projection.hh\"\r\n#include \"pl_problem.hh\"\r\n#include \"Sa_problem.hh\"\r\n#include \"Sv_problem.hh\"\r\n\r\n\r\n// PETSc stuff\r\n#include <deal.II/lac/petsc_vector.h>\r\n#include <deal.II/lac/petsc_solver.h>\r\n\r\n\r\n#include <cstdlib>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <algorithm>\r\n\r\n\r\nnamespace CouplingPressureSaturation {\r\n    using namespace dealii;\r\n\r\n\r\n\r\n    class ParameterReader : public Subscriptor {\r\n    public:\r\n        explicit ParameterReader(ParameterHandler &);\r\n\r\n        void read_parameters(const std::string &);\r\n\r\n    private:\r\n        void declare_parameters();\r\n\r\n        ParameterHandler &prm;\r\n    };\r\n\r\n    ParameterReader::ParameterReader(ParameterHandler &paramhandler)\r\n            : prm(paramhandler) {}\r\n\r\n\r\n    void ParameterReader::declare_parameters() {\r\n\r\n        prm.enter_subsection(\"Time discretization parameters\");\r\n        {\r\n            prm.declare_entry(\"Final time\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Initial time step\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Second order time derivative\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Second order extrapolation\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use implicit time term in pl\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Create initial perturbation\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n            prm.declare_entry(\"Midpoint method\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n            prm.declare_entry(\"Theta_n\",\r\n                              \"0.5\",\r\n                              Patterns::Double(0.0));\r\n\r\n        }\r\n        prm.leave_subsection();\r\n\r\n\r\n        prm.enter_subsection(\"Spatial discretization parameters\");\r\n        {\r\n            prm.declare_entry(\"Dimension\",\r\n                              \"2\",\r\n                              Patterns::Integer(2));\r\n\r\n            prm.declare_entry(\"Degree\",\r\n                              \"1\",\r\n                              Patterns::Integer(1));\r\n\r\n            prm.declare_entry(\"Initial level of refinement\",\r\n                              \"0\",\r\n                              Patterns::Integer(0));\r\n\r\n            prm.declare_entry(\"Final level of refinement\",\r\n                              \"7\",\r\n                              Patterns::Integer(0));\r\n\r\n            prm.declare_entry(\"Incompressible\",\r\n                              \"true\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Stab_a\",\r\n                              \"true\",\r\n                              Patterns::Bool());\r\n            prm.declare_entry(\"Stab_v\",\r\n                              \"true\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Theta pl\",\r\n                              \"1.0\",\r\n                              Patterns::Double());\r\n\r\n            prm.declare_entry(\"Theta Sa\",\r\n                              \"1.0\",\r\n                              Patterns::Double());\r\n\r\n            prm.declare_entry(\"Theta Sv\",\r\n                              \"1.0\",\r\n                              Patterns::Double());\r\n\r\n            prm.declare_entry(\"Penalty pl\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Penalty Sa\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Penalty Sv\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Penalty pl boundary\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Penalty Sa boundary\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Penalty Sv boundary\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Project to RT0\",\r\n                              \"true\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Project to RT0 with kappa only\",\r\n                              \"true\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use direct solver for linear systems\",\r\n                              \"true\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact pl in Sa\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact pl in Sv\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact pl in RT\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact Sa in pl\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact Sa in Sv\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact Sa in RT\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact Sv in pl\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact Sv in Sa\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Use exact Sv in RT\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Project Darcy with gravity\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Add explicit artificial viscosity\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Add implicit artificial viscosity\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Artificial viscosity multiple for Sa\",\r\n                              \"1.0\",\r\n                              Patterns::Double(0.0));\r\n\r\n            prm.declare_entry(\"Two phase problem\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n        }\r\n        prm.leave_subsection();\r\n\r\n        prm.enter_subsection(\"Output parameters\");\r\n        {\r\n            prm.declare_entry(\"print vtk\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Frequency for vtk printing\",\r\n                              \"1\",\r\n                              Patterns::Integer(1));\r\n\r\n            prm.declare_entry(\"Compute errors\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Compute energy\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n        }\r\n        prm.leave_subsection();\r\n\r\n        prm.enter_subsection(\"Continuation from previous solution\");\r\n        {\r\n            prm.declare_entry(\"Output solution\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Frequency for solution output\",\r\n                              \"1\",\r\n                              Patterns::Integer(1));\r\n\r\n            prm.declare_entry(\"Continue solution\",\r\n                              \"false\",\r\n                              Patterns::Bool());\r\n\r\n            prm.declare_entry(\"Time step number\",\r\n                              \"1\",\r\n                              Patterns::Integer(1));\r\n        }\r\n        prm.leave_subsection();\r\n    }\r\n\r\n    void ParameterReader::read_parameters(const std::string &parameter_file) {\r\n        declare_parameters();\r\n\r\n        prm.parse_input(parameter_file);\r\n    }\r\n\r\n    template<int dim>\r\n    class CoupledPressureSaturationProblem {\r\n    public:\r\n        CoupledPressureSaturationProblem(unsigned int degree, unsigned int degreeRT_,\r\n                                         double delta_t, double tf, unsigned int refinement,\r\n                                         ParameterHandler &param);\r\n\r\n        void run();\r\n\r\n    private:\r\n        void load_gmsh_mesh();\r\n\r\n        void setup_system();\r\n\r\n        void compute_errors() const;\r\n\r\n        void compute_energy_norm_error_pl() const;\r\n\r\n        void output_vtk_initial_cond() const;\r\n\r\n        void output_vtk() const;\r\n\r\n        void output_solution() const;\r\n\r\n        void read_initial_condition();\r\n\r\n        void create_kappa_abs_vector();\r\n\r\n        double calculate_energy(double &real_energy);\r\n\r\n\r\n        parallel::shared::Triangulation<dim> triangulation;\r\n\r\n        std::vector<unsigned int> dirichlet_id_pl, dirichlet_id_sa, dirichlet_id_sv;\r\n\r\n        const MappingQ1<dim> mapping;\r\n\r\n        // DG space\r\n        FE_DGQ<dim> fe;\r\n        DoFHandler<dim> dof_handler;\r\n        const unsigned int degree;\r\n\r\n        // RT Projection space\r\n        FE_RaviartThomas<dim> fe_RT;\r\n        DoFHandler<dim> dof_handler_RT;\r\n        const unsigned int degreeRT;\r\n\r\n        MPI_Comm mpi_communicator;\r\n\r\n        const unsigned int n_mpi_processes;\r\n        const unsigned int this_mpi_process;\r\n\r\n        ConditionalOStream pcout;\r\n\r\n        IndexSet locally_owned_dofs;\r\n        IndexSet locally_relevant_dofs;\r\n\r\n        IndexSet locally_owned_dofs_RT;\r\n        IndexSet locally_relevant_dofs_RT;\r\n\r\n        // Solutions for BDF schemes\r\n        PETScWrappers::MPI::Vector pl_solution;\r\n        PETScWrappers::MPI::Vector pl_solution_n;\r\n        PETScWrappers::MPI::Vector pl_solution_nminus1;\r\n        PETScWrappers::MPI::Vector pl_solution_nminus2;\r\n\r\n        PETScWrappers::MPI::Vector Sa_solution;\r\n        PETScWrappers::MPI::Vector Sa_solution_n;\r\n        PETScWrappers::MPI::Vector Sa_solution_nminus1;\r\n        PETScWrappers::MPI::Vector Sa_solution_nminus2;\r\n\r\n        PETScWrappers::MPI::Vector Sv_solution;\r\n        PETScWrappers::MPI::Vector Sv_solution_n;\r\n        PETScWrappers::MPI::Vector Sv_solution_nminus1;\r\n        PETScWrappers::MPI::Vector Sv_solution_nminus2;\r\n\r\n        // Solutions for Midpoint scheme\r\n        PETScWrappers::MPI::Vector pl_solution_k;\r\n        PETScWrappers::MPI::Vector pl_solution_kplus1;\r\n\r\n\r\n        PETScWrappers::MPI::Vector Sa_solution_k;\r\n        PETScWrappers::MPI::Vector Sa_solution_kplus1;\r\n\r\n        PETScWrappers::MPI::Vector Sv_solution_k;\r\n        PETScWrappers::MPI::Vector Sv_solution_kplus1;\r\n\r\n        PETScWrappers::MPI::Vector pl_difference;\r\n        PETScWrappers::MPI::Vector Sa_difference;\r\n        PETScWrappers::MPI::Vector Sv_difference;\r\n\r\n        // RT Projection vector\r\n        PETScWrappers::MPI::Vector totalDarcyvelocity_RT_Sa;\r\n        PETScWrappers::MPI::Vector totalDarcyvelocity_RT_Sa_n;\r\n        PETScWrappers::MPI::Vector totalDarcyvelocity_RT_Sv;\r\n        PETScWrappers::MPI::Vector totalDarcyvelocity_RT_Sv_n;\r\n\r\n        // Kappa stuff\r\n        FE_DGQ<dim> fe_dg0;\r\n        DoFHandler<dim> dof_handler_dg0;\r\n        IndexSet locally_owned_dofs_dg0;\r\n        IndexSet locally_relevant_dofs_dg0;\r\n        PETScWrappers::MPI::Vector kappa_abs_vec;\r\n\r\n        ParameterHandler &prm;\r\n\r\n        double time_step;\r\n        double time;\r\n        unsigned int timestep_number;\r\n        double final_time;\r\n        bool midpoint_method;\r\n        double theta_n_time;\r\n\r\n        bool incompressible;\r\n\r\n        bool Stab_a;\r\n        bool Stab_v;\r\n\r\n        double penalty_pl;\r\n        double penalty_Sa;\r\n        double penalty_Sv;\r\n\r\n        double penalty_pl_bdry;\r\n        double penalty_Sa_bdry;\r\n        double penalty_Sv_bdry;\r\n\r\n        double theta_pl;\r\n        double theta_Sa;\r\n        double theta_Sv;\r\n\r\n        unsigned int ref_level;\r\n\r\n        bool print_vtk;\r\n        int vtk_freq;\r\n        bool compute_errors_sol;\r\n        bool compute_energy;\r\n\r\n        bool output_sol;\r\n        int output_sol_freq;\r\n        bool continue_solution;\r\n\r\n        bool second_order_time_derivative;\r\n        bool second_order_extrapolation;\r\n\r\n        bool implicit_time_pl;\r\n\r\n        bool create_initial_perturbation;\r\n\r\n        bool use_exact_pl_in_Sa;\r\n        bool use_exact_pl_in_Sv;\r\n        bool use_exact_pl_in_RT;\r\n        bool use_exact_Sa_in_pl;\r\n        bool use_exact_Sa_in_Sv;\r\n        bool use_exact_Sa_in_RT;\r\n        bool use_exact_Sv_in_pl;\r\n        bool use_exact_Sv_in_Sa;\r\n        bool use_exact_Sv_in_RT;\r\n\r\n        bool project_to_RT0;\r\n        bool project_Darcy_with_gravity;\r\n        bool project_only_kappa;\r\n\r\n        bool use_direct_solver;\r\n\r\n        bool artificial_visc_exp;\r\n        bool artificial_visc_imp;\r\n        double art_visc_multiple_Sa;\r\n\r\n        bool two_phase;\r\n\r\n        AffineConstraints<double> constraints;\r\n\r\n    };\r\n\r\n    template<int dim>\r\n    CoupledPressureSaturationProblem<dim>::CoupledPressureSaturationProblem(const unsigned int degree,\r\n                                                                            const unsigned int degreeRT_,\r\n                                                                            double delta_t, double tf,\r\n                                                                            const unsigned int refinement,\r\n                                                                            ParameterHandler &param)\r\n            : triangulation(MPI_COMM_WORLD), mapping(), degree(degree), degreeRT(degreeRT_), fe(degree),\r\n              fe_RT(degreeRT_), time_step(delta_t), final_time(tf), ref_level(refinement), dof_handler(triangulation),\r\n              dof_handler_RT(triangulation), fe_dg0(0), dof_handler_dg0(triangulation), prm(param),\r\n              mpi_communicator(MPI_COMM_WORLD), n_mpi_processes(Utilities::MPI::n_mpi_processes(mpi_communicator)),\r\n              this_mpi_process(Utilities::MPI::this_mpi_process(mpi_communicator)),\r\n              pcout(std::cout, (this_mpi_process == 0)) {\r\n        prm.enter_subsection(\"Time discretization parameters\");\r\n\r\n        second_order_time_derivative = prm.get_bool(\"Second order time derivative\");\r\n        second_order_extrapolation = prm.get_bool(\"Second order extrapolation\");\r\n        implicit_time_pl = prm.get_bool(\"Use implicit time term in pl\");\r\n        create_initial_perturbation = prm.get_bool(\"Create initial perturbation\");\r\n        midpoint_method = prm.get_bool(\"Midpoint method\");\r\n        theta_n_time = prm.get_double(\"Theta_n\");\r\n\r\n\r\n        prm.leave_subsection();\r\n\r\n        prm.enter_subsection(\"Spatial discretization parameters\");\r\n\r\n\r\n        incompressible = prm.get_bool(\"Incompressible\");\r\n\r\n\r\n        Stab_a = prm.get_bool(\"Stab_a\");\r\n        Stab_v = prm.get_bool(\"Stab_v\");\r\n\r\n        theta_pl = prm.get_double(\"Theta pl\");\r\n        theta_Sa = prm.get_double(\"Theta Sa\");\r\n        theta_Sv = prm.get_double(\"Theta Sv\");\r\n\r\n        penalty_pl = prm.get_double(\"Penalty pl\");\r\n        penalty_Sa = prm.get_double(\"Penalty Sa\");\r\n        penalty_Sv = prm.get_double(\"Penalty Sv\");\r\n\r\n        penalty_pl_bdry = prm.get_double(\"Penalty pl boundary\");\r\n        penalty_Sa_bdry = prm.get_double(\"Penalty Sa boundary\");\r\n        penalty_Sv_bdry = prm.get_double(\"Penalty Sv boundary\");\r\n\r\n        project_to_RT0 = prm.get_bool(\"Project to RT0\");\r\n        project_only_kappa = prm.get_bool(\"Project to RT0 with kappa only\");\r\n        project_Darcy_with_gravity = prm.get_bool(\"Project Darcy with gravity\");\r\n\r\n        use_direct_solver = prm.get_bool(\"Use direct solver for linear systems\");\r\n\r\n        use_exact_pl_in_Sa = prm.get_bool(\"Use exact pl in Sa\");\r\n        use_exact_pl_in_Sv = prm.get_bool(\"Use exact pl in Sv\");\r\n        use_exact_pl_in_RT = prm.get_bool(\"Use exact pl in RT\");\r\n        use_exact_Sa_in_pl = prm.get_bool(\"Use exact Sa in pl\");\r\n        use_exact_Sa_in_Sv = prm.get_bool(\"Use exact Sa in Sv\");\r\n        use_exact_Sa_in_RT = prm.get_bool(\"Use exact Sa in RT\");\r\n        use_exact_Sv_in_pl = prm.get_bool(\"Use exact Sv in pl\");\r\n        use_exact_Sv_in_Sa = prm.get_bool(\"Use exact Sv in Sa\");\r\n        use_exact_Sv_in_RT = prm.get_bool(\"Use exact Sv in RT\");\r\n\r\n        artificial_visc_exp = prm.get_bool(\"Add explicit artificial viscosity\");\r\n        artificial_visc_imp = prm.get_bool(\"Add implicit artificial viscosity\");\r\n        art_visc_multiple_Sa = prm.get_double(\"Artificial viscosity multiple for Sa\");\r\n\r\n        two_phase = prm.get_bool(\"Two phase problem\");\r\n\r\n        prm.leave_subsection();\r\n\r\n        prm.enter_subsection(\"Output parameters\");\r\n        print_vtk = prm.get_bool(\"print vtk\");\r\n        vtk_freq = prm.get_integer(\"Frequency for vtk printing\");\r\n        compute_errors_sol = prm.get_bool(\"Compute errors\");\r\n        compute_energy = prm.get_bool(\"Compute energy\");\r\n        prm.leave_subsection();\r\n\r\n        prm.enter_subsection(\"Continuation from previous solution\");\r\n        output_sol = prm.get_bool(\"Output solution\");\r\n        output_sol_freq = prm.get_integer(\"Frequency for solution output\");\r\n        continue_solution = prm.get_bool(\"Continue solution\");\r\n\r\n        if (continue_solution)\r\n            timestep_number = prm.get_integer(\"Time step number\");\r\n        else\r\n            timestep_number = 2;\r\n\r\n        prm.leave_subsection();\r\n\r\n\r\n        time = timestep_number * time_step;\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::create_kappa_abs_vector() {\r\n        for (const auto &cell: dof_handler.active_cell_iterators()) {\r\n            if (cell->subdomain_id() == this_mpi_process) {\r\n                double kappa_val = compute_kappa_value<dim>(cell);\r\n                kappa_abs_vec[cell->global_active_cell_index()] = kappa_val;\r\n            }\r\n            kappa_abs_vec.compress(VectorOperation::insert);\r\n        }\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::setup_system() {\r\n\r\n        dof_handler.distribute_dofs(fe);\r\n        dof_handler_RT.distribute_dofs(fe_RT);\r\n\r\n        const std::vector<IndexSet> locally_owned_dofs_per_proc =\r\n                DoFTools::locally_owned_dofs_per_subdomain(dof_handler);\r\n        locally_owned_dofs = locally_owned_dofs_per_proc[this_mpi_process];\r\n\r\n        DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);\r\n\r\n        const std::vector<IndexSet> locally_owned_dofs_per_proc_RT =\r\n                DoFTools::locally_owned_dofs_per_subdomain(dof_handler_RT);\r\n        locally_owned_dofs_RT = locally_owned_dofs_per_proc_RT[this_mpi_process];\r\n\r\n        DoFTools::extract_locally_relevant_dofs(dof_handler_RT, locally_relevant_dofs_RT);\r\n\r\n        pl_solution.reinit(locally_owned_dofs, mpi_communicator);\r\n        pl_solution_n.reinit(locally_owned_dofs, mpi_communicator);\r\n        pl_solution_k.reinit(locally_owned_dofs, mpi_communicator);\r\n        pl_solution_kplus1.reinit(locally_owned_dofs, mpi_communicator);\r\n        pl_solution_nminus1.reinit(locally_owned_dofs, mpi_communicator);\r\n        pl_solution_nminus2.reinit(locally_owned_dofs, mpi_communicator);\r\n\r\n\r\n        Sa_solution.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sa_solution_n.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sa_solution_k.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sa_solution_kplus1.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sa_solution_nminus1.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sa_solution_nminus2.reinit(locally_owned_dofs, mpi_communicator);\r\n\r\n\r\n        Sv_solution.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sv_solution_n.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sv_solution_k.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sv_solution_kplus1.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sv_solution_nminus1.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sv_solution_nminus2.reinit(locally_owned_dofs, mpi_communicator);\r\n        pl_difference.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sa_difference.reinit(locally_owned_dofs, mpi_communicator);\r\n        Sv_difference.reinit(locally_owned_dofs, mpi_communicator);\r\n\r\n        totalDarcyvelocity_RT_Sa.reinit(locally_owned_dofs_RT, mpi_communicator);\r\n        totalDarcyvelocity_RT_Sa_n.reinit(locally_owned_dofs_RT, mpi_communicator);\r\n\r\n        totalDarcyvelocity_RT_Sv.reinit(locally_owned_dofs_RT, mpi_communicator);\r\n        totalDarcyvelocity_RT_Sv_n.reinit(locally_owned_dofs_RT, mpi_communicator);\r\n\r\n        dof_handler_dg0.distribute_dofs(fe_dg0);\r\n        const std::vector<IndexSet> locally_owned_dofs_per_proc_dg0 =\r\n                DoFTools::locally_owned_dofs_per_subdomain(dof_handler_dg0);\r\n        locally_owned_dofs_dg0 = locally_owned_dofs_per_proc_dg0[this_mpi_process];\r\n\r\n        DoFTools::extract_locally_relevant_dofs(dof_handler_dg0, locally_relevant_dofs_dg0);\r\n\r\n        kappa_abs_vec.reinit(locally_owned_dofs_dg0, mpi_communicator);\r\n\r\n        constraints.close();\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::compute_errors() const {\r\n        // PrescribedSolution::ExactSolution<dim> exact_solution;\r\n        ExactLiquidPressure<dim> exact_solution_pressure;\r\n        exact_solution_pressure.set_time(final_time);\r\n        Vector<double> cellwise_errors_pl(triangulation.n_active_cells());\r\n\r\n        ExactAqueousSaturation<dim> exact_solution_aqueous_saturation;\r\n        exact_solution_aqueous_saturation.set_time(final_time);\r\n        Vector<double> cellwise_errors_Sa(triangulation.n_active_cells());\r\n\r\n        ExactVaporSaturation<dim> exact_solution_vapor_saturation;\r\n        exact_solution_vapor_saturation.set_time(final_time);\r\n        Vector<double> cellwise_errors_Sv(triangulation.n_active_cells());\r\n\r\n        QTrapezoid<1> q_trapez;\r\n        QIterated<dim> quadrature(q_trapez, degree + 2);\r\n\r\n        // With this, we can then let the library compute the errors and output\r\n        // them to the screen:\r\n        VectorTools::integrate_difference(dof_handler,\r\n                                          pl_solution,\r\n                                          exact_solution_pressure,\r\n                                          cellwise_errors_pl,\r\n                                          quadrature,\r\n                                          VectorTools::L2_norm);\r\n        const double pl_l2_error =\r\n                VectorTools::compute_global_error(triangulation,\r\n                                                  cellwise_errors_pl,\r\n                                                  VectorTools::L2_norm);\r\n\r\n        VectorTools::integrate_difference(dof_handler,\r\n                                          Sa_solution,\r\n                                          exact_solution_aqueous_saturation,\r\n                                          cellwise_errors_Sa,\r\n                                          quadrature,\r\n                                          VectorTools::L2_norm);\r\n        const double Sa_l2_error =\r\n                VectorTools::compute_global_error(triangulation,\r\n                                                  cellwise_errors_Sa,\r\n                                                  VectorTools::L2_norm);\r\n\r\n        VectorTools::integrate_difference(dof_handler,\r\n                                          Sv_solution,\r\n                                          exact_solution_vapor_saturation,\r\n                                          cellwise_errors_Sv,\r\n                                          quadrature,\r\n                                          VectorTools::L2_norm);\r\n        const double Sv_l2_error =\r\n                VectorTools::compute_global_error(triangulation,\r\n                                                  cellwise_errors_Sv,\r\n                                                  VectorTools::L2_norm);\r\n\r\n\r\n        pcout << \"Errors: \" << std::endl;\r\n        pcout << \"||e_pl||_L2 = \" << pl_l2_error << std::endl;\r\n        pcout << \"||e_Sa||_L2 = \" << Sa_l2_error << std::endl;\r\n        pcout << \"||e_Sv||_L2 = \" << Sv_l2_error << std::endl;\r\n\r\n        compute_energy_norm_error_pl();\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::compute_energy_norm_error_pl() const {\r\n        ExactLiquidPressure<dim> exact_solution_pressure;\r\n        exact_solution_pressure.set_time(final_time);\r\n\r\n        PETScWrappers::MPI::Vector temp_pl_solution;\r\n        temp_pl_solution.reinit(locally_owned_dofs,\r\n                                locally_relevant_dofs,\r\n                                mpi_communicator);\r\n\r\n        temp_pl_solution = pl_solution;\r\n\r\n        const QGauss<dim> quadrature_formula(degree + 1);\r\n        const QGauss<dim - 1> face_quadrature_formula(degree + 1);\r\n\r\n        FEValues<dim> fe_values_DG(fe,\r\n                                   quadrature_formula,\r\n                                   update_values | update_gradients |\r\n                                   update_quadrature_points |\r\n                                   update_JxW_values);\r\n\r\n        FEFaceValues<dim> fe_face_values_DG(fe,\r\n                                            face_quadrature_formula,\r\n                                            update_values | update_gradients |\r\n                                            update_normal_vectors |\r\n                                            update_quadrature_points |\r\n                                            update_JxW_values);\r\n\r\n        FEFaceValues<dim> fe_face_values_DG_neighbor(fe,\r\n                                                     face_quadrature_formula,\r\n                                                     update_values | update_gradients |\r\n                                                     update_normal_vectors |\r\n                                                     update_quadrature_points |\r\n                                                     update_JxW_values);\r\n\r\n        typename DoFHandler<dim>::active_cell_iterator\r\n                cell_DG = dof_handler.begin_active(),\r\n                endc = dof_handler.end();\r\n\r\n        double cell_term = 0.0;\r\n        double face_term = 0.0;\r\n\r\n        for (; cell_DG != endc; ++cell_DG) {\r\n            if (cell_DG->subdomain_id() == this_mpi_process) {\r\n                fe_values_DG.reinit(cell_DG);\r\n\r\n                unsigned int cell_index = cell_DG->active_cell_index();\r\n\r\n                const auto &q_points = fe_values_DG.get_quadrature_points();\r\n                const unsigned int n_q_points_DG = fe_values_DG.get_quadrature().size();\r\n                const std::vector<double> &JxW = fe_values_DG.get_JxW_values();\r\n\r\n                std::vector<double> pl_vals_cell(n_q_points_DG);\r\n                fe_values_DG.get_function_values(temp_pl_solution, pl_vals_cell);\r\n\r\n                std::vector<Tensor<1, dim>> grad_pl_cell(n_q_points_DG);\r\n                fe_values_DG.get_function_gradients(temp_pl_solution, grad_pl_cell);\r\n\r\n                Tensor<1, dim> grad_exact;\r\n\r\n                double norm_square = 0;\r\n\r\n                for (unsigned int q = 0; q < n_q_points_DG; ++q) {\r\n                    Tensor<1, dim> pl_grad = grad_pl_cell[q];\r\n                    grad_exact = exact_solution_pressure.gradient(q_points[q]);\r\n                    norm_square += (pl_grad - grad_exact).norm_square() * JxW[q];\r\n                }\r\n\r\n                cell_term += norm_square;\r\n\r\n                for (const auto &face: cell_DG->face_iterators()) {\r\n                    fe_face_values_DG.reinit(cell_DG, face);\r\n\r\n                    unsigned int face_num = cell_DG->face_iterator_to_index(face);\r\n\r\n                    const auto &q_points = fe_face_values_DG.get_quadrature_points();\r\n                    const unsigned int n_q_points_face_DG = fe_face_values_DG.get_quadrature().size();\r\n                    const std::vector<double> &JxW = fe_face_values_DG.get_JxW_values();\r\n\r\n                    if (face->at_boundary()) {\r\n                        std::vector<double> pl_vals_face(n_q_points_face_DG);\r\n                        fe_face_values_DG.get_function_values(temp_pl_solution, pl_vals_face);\r\n\r\n                        double difference_norm_square = 0.;\r\n                        for (unsigned int q = 0; q < n_q_points_face_DG; ++q) {\r\n                            double pl_value = pl_vals_face[q];\r\n\r\n                            const double diff = (exact_solution_pressure.value(q_points[q]) - pl_value);\r\n                            difference_norm_square += diff * diff * JxW[q];\r\n                        }\r\n\r\n                        face_term += (1.0 / cell_DG->face(face_num)->measure()) * difference_norm_square;\r\n                    } else {\r\n                        typename DoFHandler<dim>::active_cell_iterator cell_DG_neighbor = cell_DG->neighbor(face_num);\r\n                        unsigned int neighbor_index = cell_DG->neighbor_index(face_num);\r\n\r\n                        if (cell_index >= neighbor_index)\r\n                            continue;\r\n\r\n                        fe_face_values_DG_neighbor.reinit(cell_DG_neighbor, face);\r\n\r\n                        std::vector<double> pl_vals_face(n_q_points_face_DG);\r\n                        fe_face_values_DG.get_function_values(temp_pl_solution, pl_vals_face);\r\n\r\n                        std::vector<double> pl_vals_face_neighbor(n_q_points_face_DG);\r\n                        fe_face_values_DG_neighbor.get_function_values(temp_pl_solution, pl_vals_face_neighbor);\r\n\r\n                        double pl_jump_square = 0;\r\n                        for (unsigned int q = 0; q < n_q_points_face_DG; ++q) {\r\n                            double pl_value0 = pl_vals_face[q];\r\n                            double pl_value1 = pl_vals_face_neighbor[q];\r\n\r\n                            double jump_pl = pl_value0 - pl_value1;\r\n                            pl_jump_square += jump_pl * jump_pl * JxW[q];\r\n                        }\r\n\r\n                        face_term += (1.0 / cell_DG->face(face_num)->measure()) * pl_jump_square;\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const double energy_error = std::sqrt(cell_term + face_term);\r\n\r\n        pcout << \"Triple norm error p_l: \" << std::endl;\r\n        pcout << \"|||e_pl||| = \" << energy_error << std::endl;\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::output_vtk_initial_cond() const {\r\n        DataOutBase::VtkFlags flags;\r\n        flags.compression_level = DataOutBase::VtkFlags::best_speed;\r\n\r\n        // To print kappa_abs vector\r\n        kappa_abs_vec.update_ghost_values();\r\n\r\n        DataOut<dim> data_kappa;\r\n\r\n        data_kappa.attach_dof_handler(dof_handler_dg0);\r\n        data_kappa.add_data_vector(kappa_abs_vec, \"kappa\", DataOut<dim>::type_dof_data);\r\n        data_kappa.build_patches(mapping);\r\n\r\n        data_kappa.set_flags(flags);\r\n        const std::string filename_kappa =\r\n                \"kappa.vtu\";\r\n        data_kappa.write_vtu_in_parallel(filename_kappa, mpi_communicator);\r\n        // end of printing kappa_abs vector\r\n\r\n        pl_solution_nminus1.update_ghost_values();\r\n\r\n        DataOut<dim> data_out_pl_nminus1;\r\n\r\n        data_out_pl_nminus1.attach_dof_handler(dof_handler);\r\n        data_out_pl_nminus1.add_data_vector(pl_solution_nminus1, \"pl\");\r\n        data_out_pl_nminus1.build_patches(mapping);\r\n\r\n        data_out_pl_nminus1.set_flags(flags);\r\n        const std::string filename_pl_0 =\r\n                \"solution_pl-000.vtu\";\r\n        data_out_pl_nminus1.write_vtu_in_parallel(filename_pl_0, mpi_communicator);\r\n\r\n        pl_solution_n.update_ghost_values();\r\n\r\n        DataOut<dim> data_out_pl_n;\r\n\r\n        data_out_pl_n.attach_dof_handler(dof_handler);\r\n        data_out_pl_n.add_data_vector(pl_solution_n, \"pl\");\r\n        data_out_pl_n.build_patches(mapping);\r\n\r\n        data_out_pl_n.set_flags(flags);\r\n        const std::string filename_pl_1 =\r\n                \"solution_pl-001.vtu\";\r\n        data_out_pl_n.write_vtu_in_parallel(filename_pl_1, mpi_communicator);\r\n\r\n        // Sa\r\n        Sa_solution_nminus1.update_ghost_values();\r\n\r\n        DataOut<dim> data_out_Sa_nminus1;\r\n\r\n        data_out_Sa_nminus1.attach_dof_handler(dof_handler);\r\n        data_out_Sa_nminus1.add_data_vector(Sa_solution_nminus1, \"Sa\");\r\n        data_out_Sa_nminus1.build_patches(mapping);\r\n\r\n        data_out_Sa_nminus1.set_flags(flags);\r\n        const std::string filename_Sa_0 =\r\n                \"solution_Sa-000.vtu\";\r\n        data_out_Sa_nminus1.write_vtu_in_parallel(filename_Sa_0, mpi_communicator);\r\n\r\n        Sa_solution_n.update_ghost_values();\r\n\r\n        DataOut<dim> data_out_Sa_n;\r\n\r\n        data_out_Sa_n.attach_dof_handler(dof_handler);\r\n        data_out_Sa_n.add_data_vector(Sa_solution_n, \"Sa\");\r\n        data_out_Sa_n.build_patches(mapping);\r\n\r\n        data_out_Sa_n.set_flags(flags);\r\n        const std::string filename_Sa_1 =\r\n                \"solution_Sa-001.vtu\";\r\n        data_out_Sa_n.write_vtu_in_parallel(filename_Sa_1, mpi_communicator);\r\n\r\n        // Sv\r\n        if (!two_phase) {\r\n            Sv_solution_nminus1.update_ghost_values();\r\n\r\n            DataOut<dim> data_out_Sv_nminus1;\r\n\r\n            data_out_Sv_nminus1.attach_dof_handler(dof_handler);\r\n            data_out_Sv_nminus1.add_data_vector(Sv_solution_nminus1, \"Sv\");\r\n            data_out_Sv_nminus1.build_patches(mapping);\r\n\r\n            data_out_Sv_nminus1.set_flags(flags);\r\n            const std::string filename_Sv_0 =\r\n                    \"solution_Sv-000.vtu\";\r\n            data_out_Sv_nminus1.write_vtu_in_parallel(filename_Sv_0, mpi_communicator);\r\n\r\n            Sv_solution_n.update_ghost_values();\r\n\r\n            DataOut<dim> data_out_Sv_n;\r\n\r\n            data_out_Sv_n.attach_dof_handler(dof_handler);\r\n            data_out_Sv_n.add_data_vector(Sv_solution_n, \"Sv\");\r\n            data_out_Sv_n.build_patches(mapping);\r\n\r\n            data_out_Sv_n.set_flags(flags);\r\n            const std::string filename_Sv_1 =\r\n                    \"solution_Sv-001.vtu\";\r\n            data_out_Sv_n.write_vtu_in_parallel(filename_Sv_1, mpi_communicator);\r\n        }\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::output_vtk() const {\r\n        DataOutBase::VtkFlags flags;\r\n        flags.compression_level = DataOutBase::VtkFlags::best_speed;\r\n\r\n        pl_solution.update_ghost_values();\r\n\r\n        DataOut<dim> data_out_pl;\r\n\r\n        data_out_pl.attach_dof_handler(dof_handler);\r\n        data_out_pl.add_data_vector(pl_solution, \"pl\");\r\n        data_out_pl.build_patches(mapping);\r\n\r\n        data_out_pl.set_flags(flags);\r\n        const std::string filename_pl =\r\n                \"solution_pl-\" + Utilities::int_to_string(timestep_number, 3) + \".vtu\";\r\n        data_out_pl.write_vtu_in_parallel(filename_pl, mpi_communicator);\r\n\r\n        // Sa\r\n        Sa_solution.update_ghost_values();\r\n\r\n        DataOut<dim> data_out_Sa;\r\n\r\n        data_out_Sa.attach_dof_handler(dof_handler);\r\n        data_out_Sa.add_data_vector(Sa_solution, \"Sa\");\r\n        data_out_Sa.build_patches(mapping);\r\n\r\n        data_out_Sa.set_flags(flags);\r\n        const std::string filename_Sa =\r\n                \"solution_Sa-\" + Utilities::int_to_string(timestep_number, 3) + \".vtu\";\r\n        data_out_Sa.write_vtu_in_parallel(filename_Sa, mpi_communicator);\r\n\r\n        // Sv\r\n        if (!two_phase) {\r\n            Sv_solution.update_ghost_values();\r\n\r\n            DataOut<dim> data_out_Sv;\r\n\r\n            data_out_Sv.attach_dof_handler(dof_handler);\r\n            data_out_Sv.add_data_vector(Sv_solution, \"Sv\");\r\n            data_out_Sv.build_patches(mapping);\r\n\r\n            data_out_Sv.set_flags(flags);\r\n            const std::string filename_Sv =\r\n                    \"solution_Sv-\" + Utilities::int_to_string(timestep_number, 3) + \".vtu\";\r\n            data_out_Sv.write_vtu_in_parallel(filename_Sv, mpi_communicator);\r\n        }\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::output_solution() const {\r\n        Vector<double> Sa_serial_nminus2(Sa_solution_nminus2), pl_serial_nminus2(pl_solution_nminus2);\r\n        Vector<double> Sa_serial_nminus1(Sa_solution_nminus1), pl_serial_nminus1(pl_solution_nminus1);\r\n        Vector<double> Sa_serial_n(Sa_solution_n), pl_serial_n(pl_solution_n);\r\n        Vector<double> Sa_serial(Sa_solution), pl_serial(pl_solution);\r\n\r\n        std::ofstream myfile_sa, myfile_pl;\r\n\r\n        std::string myfilename_sa;\r\n        std::string myfilename_pl;\r\n\r\n        if (second_order_extrapolation || second_order_time_derivative) {\r\n            myfilename_sa = \"Sa_solution\" + Utilities::int_to_string(timestep_number - 3, 3);\r\n            myfilename_pl = \"pl_solution\" + Utilities::int_to_string(timestep_number - 3, 3);\r\n\r\n            myfile_sa.open(myfilename_sa);\r\n            myfile_pl.open(myfilename_pl);\r\n\r\n            myfile_sa << Sa_serial_nminus2.size() << std::endl;\r\n            myfile_pl << pl_serial_nminus2.size() << std::endl;\r\n\r\n            for (unsigned int jj = 0; jj < Sa_serial_nminus2.size(); jj++) {\r\n                myfile_sa << std::setprecision(16) << Sa_serial_nminus2[jj] << std::endl;\r\n                myfile_pl << std::setprecision(16) << pl_serial_nminus2[jj] << std::endl;\r\n            }\r\n\r\n            myfile_sa.close();\r\n            myfile_pl.close();\r\n        }\r\n\r\n        myfilename_sa = \"Sa_solution\" + Utilities::int_to_string(timestep_number - 2, 3);\r\n        myfilename_pl = \"pl_solution\" + Utilities::int_to_string(timestep_number - 2, 3);\r\n\r\n        myfile_sa.open(myfilename_sa);\r\n        myfile_pl.open(myfilename_pl);\r\n\r\n        myfile_sa << Sa_serial_nminus1.size() << std::endl;\r\n        myfile_pl << pl_serial_nminus1.size() << std::endl;\r\n\r\n        for (unsigned int jj = 0; jj < Sa_serial_nminus1.size(); jj++) {\r\n            myfile_sa << std::setprecision(16) << Sa_serial_nminus1[jj] << std::endl;\r\n            myfile_pl << std::setprecision(16) << pl_serial_nminus1[jj] << std::endl;\r\n        }\r\n\r\n        myfile_sa.close();\r\n        myfile_pl.close();\r\n\r\n        myfilename_sa = \"Sa_solution\" + Utilities::int_to_string(timestep_number - 1, 3);\r\n        myfilename_pl = \"pl_solution\" + Utilities::int_to_string(timestep_number - 1, 3);\r\n\r\n        myfile_sa.open(myfilename_sa);\r\n        myfile_pl.open(myfilename_pl);\r\n\r\n        myfile_sa << Sa_serial_n.size() << std::endl;\r\n        myfile_pl << pl_serial_n.size() << std::endl;\r\n\r\n        for (unsigned int jj = 0; jj < Sa_serial_n.size(); jj++) {\r\n            myfile_sa << std::setprecision(16) << Sa_serial_n[jj] << std::endl;\r\n            myfile_pl << std::setprecision(16) << pl_serial_n[jj] << std::endl;\r\n        }\r\n\r\n        myfile_sa.close();\r\n        myfile_pl.close();\r\n\r\n        myfilename_sa = \"Sa_solution\" + Utilities::int_to_string(timestep_number, 3);\r\n        myfilename_pl = \"pl_solution\" + Utilities::int_to_string(timestep_number, 3);\r\n\r\n        myfile_sa.open(myfilename_sa);\r\n        myfile_pl.open(myfilename_pl);\r\n\r\n        myfile_sa << Sa_serial.size() << std::endl;\r\n        myfile_pl << pl_serial.size() << std::endl;\r\n\r\n        for (unsigned int jj = 0; jj < Sa_serial.size(); jj++) {\r\n            myfile_sa << std::setprecision(16) << Sa_serial[jj] << std::endl;\r\n            myfile_pl << std::setprecision(16) << pl_serial[jj] << std::endl;\r\n        }\r\n\r\n        myfile_sa.close();\r\n        myfile_pl.close();\r\n\r\n        if (!two_phase) {\r\n            Vector<double> Sv_serial_nminus2(Sv_solution_nminus2);\r\n            Vector<double> Sv_serial_nminus1(Sv_solution_nminus1);\r\n            Vector<double> Sv_serial_n(Sv_solution_n);\r\n            Vector<double> Sv_serial(Sv_solution);\r\n\r\n            std::ofstream myfile_sv;\r\n\r\n            std::string myfilename_sv;\r\n\r\n            if (second_order_extrapolation || second_order_time_derivative) {\r\n                myfilename_sv = \"Sv_solution\" + Utilities::int_to_string(timestep_number - 3, 3);\r\n\r\n                myfile_sv.open(myfilename_sv);\r\n\r\n                myfile_sv << Sv_serial_nminus2.size() << std::endl;\r\n\r\n                for (unsigned int jj = 0; jj < Sv_serial_nminus2.size(); jj++)\r\n                    myfile_sv << std::setprecision(16) << Sv_serial_nminus2[jj] << std::endl;\r\n\r\n                myfile_sv.close();\r\n            }\r\n\r\n            myfilename_sv = \"Sv_solution\" + Utilities::int_to_string(timestep_number - 2, 3);\r\n\r\n            myfile_sv.open(myfilename_sv);\r\n\r\n            myfile_sv << Sv_serial_nminus1.size() << std::endl;\r\n\r\n            for (unsigned int jj = 0; jj < Sv_serial_nminus1.size(); jj++)\r\n                myfile_sv << std::setprecision(16) << Sv_serial_nminus1[jj] << std::endl;\r\n\r\n            myfile_sv.close();\r\n\r\n            myfilename_sv = \"Sv_solution\" + Utilities::int_to_string(timestep_number - 1, 3);\r\n\r\n            myfile_sv.open(myfilename_sv);\r\n\r\n            myfile_sv << Sv_serial_n.size() << std::endl;\r\n\r\n            for (unsigned int jj = 0; jj < Sv_serial_n.size(); jj++)\r\n                myfile_sv << std::setprecision(16) << Sv_serial_n[jj] << std::endl;\r\n\r\n            myfile_sv.close();\r\n\r\n            myfilename_sv = \"Sv_solution\" + Utilities::int_to_string(timestep_number, 3);\r\n\r\n            myfile_sv.open(myfilename_sv);\r\n\r\n            myfile_sv << Sv_serial.size() << std::endl;\r\n\r\n            for (unsigned int jj = 0; jj < Sv_serial.size(); jj++)\r\n                myfile_sv << std::setprecision(16) << Sv_serial[jj] << std::endl;\r\n\r\n            myfile_sv.close();\r\n        }\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::read_initial_condition() {\r\n        std::ifstream myfile_sa, myfile_pl;\r\n\r\n        std::string myfilename_sa;\r\n        std::string myfilename_pl;\r\n\r\n        if (second_order_extrapolation || second_order_time_derivative) {\r\n            myfilename_sa = \"Sa_solution\"\r\n                            + Utilities::int_to_string(timestep_number - 3, 3);\r\n            myfilename_pl = \"pl_solution\"\r\n                            + Utilities::int_to_string(timestep_number - 3, 3);\r\n\r\n            myfile_sa.open(myfilename_sa);\r\n            myfile_pl.open(myfilename_pl);\r\n\r\n            unsigned int size_sol;\r\n\r\n            myfile_sa >> size_sol;\r\n            myfile_pl >> size_sol;\r\n\r\n            Vector<double> Sa_serial(size_sol), pl_serial(size_sol);\r\n\r\n            for (unsigned int i = 0; i < size_sol; i++) {\r\n                myfile_sa >> Sa_serial[i];\r\n                myfile_pl >> pl_serial[i];\r\n            }\r\n\r\n            Sa_solution_nminus2 = Sa_serial;\r\n            pl_solution_nminus2 = pl_serial;\r\n\r\n            myfile_sa.close();\r\n            myfile_pl.close();\r\n        }\r\n\r\n        myfilename_sa = \"Sa_solution\"\r\n                        + Utilities::int_to_string(timestep_number - 2, 3);\r\n        myfilename_pl = \"pl_solution\"\r\n                        + Utilities::int_to_string(timestep_number - 2, 3);\r\n\r\n        myfile_sa.open(myfilename_sa);\r\n        myfile_pl.open(myfilename_pl);\r\n\r\n        unsigned int size_sol;\r\n\r\n        myfile_sa >> size_sol;\r\n        myfile_pl >> size_sol;\r\n\r\n        Vector<double> Sa_serial(size_sol), pl_serial(size_sol);\r\n\r\n        for (unsigned int i = 0; i < size_sol; i++) {\r\n            myfile_sa >> Sa_serial[i];\r\n            myfile_pl >> pl_serial[i];\r\n        }\r\n\r\n        Sa_solution_nminus1 = Sa_serial;\r\n        pl_solution_nminus1 = pl_serial;\r\n\r\n        myfile_sa.close();\r\n        myfile_pl.close();\r\n\r\n        myfilename_sa = \"Sa_solution\"\r\n                        + Utilities::int_to_string(timestep_number - 1, 3);\r\n        myfilename_pl = \"pl_solution\"\r\n                        + Utilities::int_to_string(timestep_number - 1, 3);\r\n\r\n        myfile_sa.open(myfilename_sa);\r\n        myfile_pl.open(myfilename_pl);\r\n\r\n        myfile_sa >> size_sol;\r\n        myfile_pl >> size_sol;\r\n\r\n\r\n        for (unsigned int i = 0; i < size_sol; i++) {\r\n            myfile_sa >> Sa_serial[i];\r\n            myfile_pl >> pl_serial[i];\r\n        }\r\n\r\n        Sa_solution_n = Sa_serial;\r\n        pl_solution_n = pl_serial;\r\n\r\n        myfile_sa.close();\r\n        myfile_pl.close();\r\n\r\n        myfilename_sa = \"Sa_solution\"\r\n                        + Utilities::int_to_string(timestep_number, 3);\r\n        myfilename_pl = \"pl_solution\"\r\n                        + Utilities::int_to_string(timestep_number, 3);\r\n\r\n        myfile_sa.open(myfilename_sa);\r\n        myfile_pl.open(myfilename_pl);\r\n\r\n        myfile_sa >> size_sol;\r\n        myfile_pl >> size_sol;\r\n\r\n        for (unsigned int i = 0; i < size_sol; i++) {\r\n            myfile_sa >> Sa_serial[i];\r\n            myfile_pl >> pl_serial[i];\r\n        }\r\n\r\n        myfile_sa.close();\r\n        myfile_pl.close();\r\n\r\n        if (!two_phase) {\r\n            std::ifstream myfile_sv;\r\n\r\n            std::string myfilename_sv;\r\n\r\n            if (second_order_extrapolation || second_order_time_derivative) {\r\n                myfilename_sv = \"Sv_solution\"\r\n                                + Utilities::int_to_string(timestep_number - 3, 3);\r\n\r\n                myfile_sv.open(myfilename_sv);\r\n\r\n                unsigned int size_sol;\r\n\r\n                myfile_sv >> size_sol;\r\n\r\n                Vector<double> Sv_serial(size_sol);\r\n\r\n                for (unsigned int i = 0; i < size_sol; i++)\r\n                    myfile_sv >> Sv_serial[i];\r\n\r\n                Sv_solution_nminus2 = Sv_serial;\r\n\r\n                myfile_sv.close();\r\n            }\r\n\r\n            myfilename_sv = \"Sv_solution\"\r\n                            + Utilities::int_to_string(timestep_number - 2, 3);\r\n\r\n            myfile_sv.open(myfilename_sv);\r\n\r\n            unsigned int size_sol;\r\n\r\n            myfile_sv >> size_sol;\r\n\r\n            Vector<double> Sv_serial(size_sol);\r\n\r\n            for (unsigned int i = 0; i < size_sol; i++)\r\n                myfile_sv >> Sv_serial[i];\r\n\r\n            Sv_solution_nminus1 = Sv_serial;\r\n\r\n            myfile_sv.close();\r\n\r\n            myfilename_sv = \"Sv_solution\"\r\n                            + Utilities::int_to_string(timestep_number - 1, 3);\r\n\r\n            myfile_sv.open(myfilename_sv);\r\n\r\n            myfile_sv >> size_sol;\r\n\r\n\r\n            for (unsigned int i = 0; i < size_sol; i++)\r\n                myfile_sv >> Sv_serial[i];\r\n\r\n            Sv_solution_n = Sv_serial;\r\n\r\n            myfile_sv.close();\r\n\r\n            myfilename_sa = \"Sv_solution\"\r\n                            + Utilities::int_to_string(timestep_number, 3);\r\n\r\n            myfile_sv.open(myfilename_sv);\r\n\r\n            myfile_sv >> size_sol;\r\n\r\n            for (unsigned int i = 0; i < size_sol; i++)\r\n                myfile_sv >> Sv_serial[i];\r\n\r\n            myfile_sv.close();\r\n        }\r\n    }\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::load_gmsh_mesh() {\r\n        GridIn<dim> gridin;\r\n\r\n        gridin.attach_triangulation(triangulation);\r\n        std::ifstream f(\"example.msh\");\r\n        gridin.read_msh(f);\r\n    }\r\n\r\n    template<int dim>\r\n    double CoupledPressureSaturationProblem<dim>::calculate_energy(double &real_energy) {\r\n        double gamma_a = 5.8275;\r\n        double gamma_l = 0.5398;\r\n        double gamma_al = 3.712;\r\n\r\n        double phi = 0.2;\r\n\r\n        ExactAqueousSaturation<dim> exact_sa;\r\n        exact_sa.set_time(time);\r\n\r\n//\tAqueousPressure<dim> pressure_a;\r\n        lambda_l<dim> lambda_l;\r\n        lambda_a<dim> lambda_a;\r\n\r\n        PETScWrappers::MPI::Vector temp_Sa_solution;\r\n        temp_Sa_solution.reinit(locally_owned_dofs,\r\n                                locally_relevant_dofs,\r\n                                mpi_communicator);\r\n\r\n        temp_Sa_solution = Sa_solution;\r\n\r\n        PETScWrappers::MPI::Vector temp_pl_solution;\r\n        temp_pl_solution.reinit(locally_owned_dofs,\r\n                                locally_relevant_dofs,\r\n                                mpi_communicator);\r\n\r\n        temp_pl_solution = pl_solution;\r\n\r\n        PETScWrappers::MPI::Vector temp_kappa;\r\n        temp_kappa.reinit(locally_owned_dofs_dg0,\r\n                          locally_relevant_dofs_dg0,\r\n                          mpi_communicator);\r\n\r\n        temp_kappa = kappa_abs_vec;\r\n\r\n        const QGauss<dim> quadrature_formula(degree + 1);\r\n        const QGauss<dim - 1> face_quadrature_formula(degree + 1);\r\n\r\n        FEValues<dim> fe_values_DG(fe,\r\n                                   quadrature_formula,\r\n                                   update_values | update_gradients |\r\n                                   update_quadrature_points |\r\n                                   update_JxW_values);\r\n\r\n        FEFaceValues<dim> fe_face_values_DG(fe,\r\n                                            face_quadrature_formula,\r\n                                            update_values | update_gradients |\r\n                                            update_normal_vectors |\r\n                                            update_quadrature_points |\r\n                                            update_JxW_values);\r\n\r\n        typename DoFHandler<dim>::active_cell_iterator\r\n                cell_DG = dof_handler.begin_active(),\r\n                endc = dof_handler.end();\r\n\r\n        double energy_val = 0.0;\r\n        real_energy = 0.0;\r\n        double source_val = 0.0;\r\n\r\n        for (; cell_DG != endc; ++cell_DG) {\r\n            if (cell_DG->subdomain_id() == this_mpi_process) {\r\n                fe_values_DG.reinit(cell_DG);\r\n\r\n                unsigned int cell_index = cell_DG->active_cell_index();\r\n\r\n                const auto &q_points = fe_values_DG.get_quadrature_points();\r\n                const unsigned int n_q_points_DG = fe_values_DG.get_quadrature().size();\r\n                const std::vector<double> &JxW = fe_values_DG.get_JxW_values();\r\n\r\n                std::vector<double> Sa_vals_cell(n_q_points_DG);\r\n                fe_values_DG.get_function_values(temp_Sa_solution, Sa_vals_cell);\r\n\r\n                for (unsigned int q = 0; q < n_q_points_DG; ++q) {\r\n                    double Sa_val = Sa_vals_cell[q];\r\n                    double real_Sa = exact_sa.value(q_points[q]);\r\n\r\n                    energy_val += gamma_a * Sa_val * (log(Sa_val) - 1.0) +\r\n                                  gamma_l * (1.0 - Sa_val) * (log(1.0 - Sa_val) - 1.0)\r\n                                  + gamma_al * Sa_val * (1.0 - Sa_val);\r\n                    real_energy += gamma_a * real_Sa * (log(real_Sa) - 1.0) +\r\n                                   gamma_l * (1.0 - real_Sa) * (log(1.0 - real_Sa) - 1.0)\r\n                                   + gamma_al * real_Sa * (1.0 - real_Sa);\r\n                }\r\n\r\n                double kappa = temp_kappa[cell_DG->active_cell_index()];\r\n\r\n                for (const auto &face: cell_DG->face_iterators()) {\r\n                    fe_face_values_DG.reinit(cell_DG, face);\r\n\r\n                    unsigned int face_num = cell_DG->face_iterator_to_index(face);\r\n\r\n                    const auto &q_points = fe_face_values_DG.get_quadrature_points();\r\n                    const unsigned int n_q_points_face_DG = fe_face_values_DG.get_quadrature().size();\r\n                    const std::vector<double> &JxW = fe_face_values_DG.get_JxW_values();\r\n\r\n                    if (face->at_boundary()) {\r\n                        std::vector<double> pl_vals_face(n_q_points_face_DG);\r\n                        std::vector<double> Sa_vals_face(n_q_points_face_DG);\r\n                        std::vector<Tensor<1, dim>> pl_grads_face(n_q_points_face_DG);\r\n                        std::vector<Tensor<1, dim>> Sa_grads_face(n_q_points_face_DG);\r\n\r\n                        fe_face_values_DG.get_function_values(temp_pl_solution, pl_vals_face);\r\n                        fe_face_values_DG.get_function_values(temp_Sa_solution, Sa_vals_face);\r\n                        fe_face_values_DG.get_function_gradients(temp_pl_solution, pl_grads_face);\r\n                        fe_face_values_DG.get_function_gradients(temp_Sa_solution, Sa_grads_face);\r\n\r\n                        const std::vector<Tensor<1, dim>> &normals = fe_face_values_DG.get_normal_vectors();\r\n\r\n                        for (unsigned int q = 0; q < n_q_points_face_DG; ++q) {\r\n                            double pl_value = pl_vals_face[q];\r\n                            double Sa_value = Sa_vals_face[q];\r\n                            Tensor<1, dim> pl_grad = pl_grads_face[q];\r\n                            Tensor<1, dim> Sa_grad = Sa_grads_face[q];\r\n\r\n//\t\t\t\t\t\tdouble pa_value = pressure_a.value(pl_value, Sa_value, 0.0);\r\n//\t\t\t\t\t\tTensor<1,dim> grad_pa = pressure_a.num_gradient(Sa_value, 0.0, pl_grad, Sa_grad, Sa_grad);\r\n\r\n                            double lambda_a_val = lambda_a.value(pl_value, Sa_value, 0.0);\r\n                            double lambda_l_val = lambda_l.value(pl_value, Sa_value, 0.0);\r\n\r\n//\t\t\t\t\t\tsource_val += lambda_a_val*kappa*(grad_pa*normals[q])*pa_value;\r\n                            source_val += lambda_l_val * kappa * (pl_grad * normals[q]) * pl_value;\r\n                        }\r\n\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        real_energy *= phi;\r\n        return phi * energy_val;// - source_val;\r\n    }\r\n\r\n\r\n    template<int dim>\r\n    void CoupledPressureSaturationProblem<dim>::run() {\r\n\r\n        // create mesh. Mesh is defined in Auxilliary file\r\n        create_mesh<dim>(triangulation, ref_level, dirichlet_id_pl, dirichlet_id_sa, dirichlet_id_sv);\r\n\r\n        pcout << \"    Number of active cells:       \"\r\n              << triangulation.n_active_cells() << \" (by partition:\";\r\n        for (unsigned int p = 0; p < n_mpi_processes; ++p)\r\n            pcout << (p == 0 ? ' ' : '+')\r\n                  << (GridTools::count_cells_with_subdomain_association(\r\n                          triangulation, p));\r\n        pcout << \")\" << std::endl;\r\n\r\n        setup_system();\r\n\r\n        pcout << \"    Number of degrees of freedom: \" << dof_handler.n_dofs()\r\n              << \" (by partition:\";\r\n        for (unsigned int p = 0; p < n_mpi_processes; ++p)\r\n            pcout << (p == 0 ? ' ' : '+')\r\n                  << (DoFTools::count_dofs_with_subdomain_association(dof_handler,\r\n                                                                      p));\r\n        pcout << \")\" << std::endl;\r\n\r\n        if (create_initial_perturbation)\r\n            create_initial_Sa_vector<dim>(triangulation, mpi_communicator, n_mpi_processes, this_mpi_process);\r\n\r\n        if (continue_solution) {\r\n            read_initial_condition();\r\n\r\n            if (two_phase) {\r\n                Sv_solution_nminus2 = 0.0;\r\n                Sv_solution_nminus1 = 0.0;\r\n                Sv_solution_n = 0.0;\r\n                Sv_solution = 0.0;\r\n            }\r\n\r\n        } else {\r\n            VectorTools::project(dof_handler,\r\n                                 constraints,\r\n                                 QGauss<dim>(fe.degree + 1),\r\n                                 InitialValuesLiquidPressure<dim>(),\r\n                                 pl_solution_n);\r\n\r\n            VectorTools::project(dof_handler,\r\n                                 constraints,\r\n                                 QGauss<dim>(fe.degree + 1),\r\n                                 InitialValuesAqueousSaturation<dim>(),\r\n                                 Sa_solution_n);\r\n\r\n            if (two_phase)\r\n                Sv_solution_n = 0.0;\r\n            else\r\n                VectorTools::project(dof_handler,\r\n                                     constraints,\r\n                                     QGauss<dim>(fe.degree + 1),\r\n                                     InitialValuesVaporSaturation<dim>(),\r\n                                     Sv_solution_n);\r\n        }\r\n\r\n        pl_solution_nminus1 = pl_solution_n;\r\n        Sa_solution_nminus1 = Sa_solution_n;\r\n        Sv_solution_nminus1 = Sv_solution_n;\r\n\r\n        InitialValuesLiquidPressure_dt<dim> pl_fcn;\r\n        InitialValuesAqueousSaturation_dt<dim> Sa_fcn;\r\n        InitialValuesVaporSaturation_dt<dim> Sv_fcn;\r\n\r\n        pl_fcn.set_time(time_step);\r\n        Sa_fcn.set_time(time_step);\r\n        Sv_fcn.set_time(time_step);\r\n\r\n        VectorTools::project(dof_handler,\r\n                             constraints,\r\n                             QGauss<dim>(fe.degree + 1),\r\n                             pl_fcn,\r\n                             pl_solution_n);\r\n\r\n        VectorTools::project(dof_handler,\r\n                             constraints,\r\n                             QGauss<dim>(fe.degree + 1),\r\n                             Sa_fcn,\r\n                             Sa_solution_n);\r\n\r\n        if (two_phase)\r\n            Sv_solution_n = 0.0;\r\n        else\r\n            VectorTools::project(dof_handler,\r\n                                 constraints,\r\n                                 QGauss<dim>(fe.degree + 1),\r\n                                 Sv_fcn,\r\n                                 Sv_solution_n);\r\n\r\n        pl_solution_nminus2 = pl_solution_nminus1;\r\n        Sa_solution_nminus2 = Sa_solution_nminus1;\r\n        Sv_solution_nminus2 = Sv_solution_nminus1;\r\n\r\n        create_kappa_abs_vector();\r\n\r\n        if (print_vtk)\r\n            output_vtk_initial_cond();\r\n\r\n        unsigned int degreeRT;\r\n\r\n        if (project_to_RT0)\r\n            degreeRT = 0;\r\n        else\r\n            degreeRT = degree;\r\n\r\n        // Vectors to save computation time\r\n        Vector<double> assemble_time(final_time / time_step - timestep_number + 1);\r\n        Vector<double> solver_time(final_time / time_step - timestep_number + 1);\r\n        Vector<double> print_time(final_time / time_step - timestep_number + 1);\r\n        Vector<double> RTproj_time(final_time / time_step - timestep_number + 1);\r\n        Vector<int> iterations_per_time(final_time / time_step - timestep_number + 1);\r\n        Vector<double> max_Sa_per_time(final_time / time_step - timestep_number + 1);\r\n        Vector<double> min_Sa_per_time(final_time / time_step - timestep_number + 1);\r\n        Vector<double> energy_per_time(final_time / time_step - timestep_number + 1);\r\n        Timer timer(mpi_communicator);\r\n        Timer total_timer(mpi_communicator);\r\n\r\n\r\n        std::ofstream iter_file;\r\n        iter_file.open(\"iterations_old\");\r\n\r\n        std::ofstream errors_file;\r\n        errors_file.open(\"errors\");\r\n\r\n        std::ofstream energy_file;\r\n        energy_file.open(\"energies\");\r\n\r\n        unsigned int index_time = 0;\r\n        double total_time = 0.0;\r\n\r\n        // call constructor for unknowns\r\n        LiquidPressure::LiquidPressureProblem<dim> pl_problem(triangulation, degree,\r\n                                                              theta_pl, penalty_pl, penalty_pl_bdry, dirichlet_id_pl,\r\n                                                              use_exact_Sa_in_pl,\r\n                                                              use_exact_Sv_in_pl,\r\n                                                              second_order_time_derivative, second_order_extrapolation,\r\n                                                              use_direct_solver, incompressible,\r\n                                                              implicit_time_pl,\r\n                                                              kappa_abs_vec, mpi_communicator, n_mpi_processes,\r\n                                                              this_mpi_process);\r\n        pl_problem.setup_system();\r\n\r\n        AqueousSaturation::AqueousSaturationProblem<dim> Sa_problem(triangulation, degree,\r\n                                                                    theta_Sa, penalty_Sa, penalty_Sa_bdry,\r\n                                                                    dirichlet_id_sa, use_exact_pl_in_Sa,\r\n                                                                    use_exact_Sv_in_Sa,\r\n                                                                    second_order_time_derivative,\r\n                                                                    second_order_extrapolation,\r\n                                                                    use_direct_solver, Stab_a, incompressible,\r\n                                                                    project_Darcy_with_gravity, artificial_visc_exp,\r\n                                                                    artificial_visc_imp, art_visc_multiple_Sa,\r\n                                                                    kappa_abs_vec, degreeRT,\r\n                                                                    project_only_kappa,\r\n                                                                    mpi_communicator, n_mpi_processes,\r\n                                                                    this_mpi_process);\r\n\r\n        Sa_problem.setup_system();\r\n\r\n        VaporSaturation::VaporSaturationProblem<dim> Sv_problem(triangulation, degree, theta_n_time,\r\n                                                                theta_Sv, penalty_Sv, penalty_Sv_bdry,\r\n                                                                dirichlet_id_sv, use_exact_pl_in_Sv,\r\n                                                                use_exact_Sa_in_Sv,\r\n                                                                second_order_time_derivative,\r\n                                                                second_order_extrapolation,\r\n                                                                use_direct_solver, Stab_v, incompressible,\r\n                                                                project_Darcy_with_gravity,\r\n                                                                kappa_abs_vec,\r\n                                                                degreeRT, project_only_kappa,\r\n                                                                mpi_communicator, n_mpi_processes,\r\n                                                                this_mpi_process);\r\n\r\n\t    Sv_problem.setup_system();\r\n\r\n        // start of sequential scheme\r\n\r\n\t// define rebuilding of matrix\r\n        bool rebuild_Sa_mat = true;\r\n\t    bool rebuild_Sv_mat = true;\r\n\r\n        for (; time <= final_time + 1.e-12; time += time_step, ++timestep_number)\r\n        {\r\n            // first print time step\r\n            pcout << \"Time step \" << timestep_number << \" at t=\" << time\r\n                  << std::endl;\r\n            // Midpoint method\r\n            if (midpoint_method && incompressible)\r\n            {\r\n                std::cerr << \"ERROR! Midpoint method DISABLED\" << std::endl;\r\n                std::abort();\r\n            }\r\n            else if (midpoint_method && !incompressible)\r\n            {\r\n                std::cerr << \"ERROR! Midpoint method must have incompressible to be true\" << std::endl;\r\n                std::abort();\r\n            }\r\n\r\n                // first assemble system matrix for pl\r\n            timer.reset();\r\n            timer.start();\r\n            pl_problem.assemble_system_pl(time_step, time, timestep_number,\r\n                                          pl_solution_n,\r\n                                          pl_solution_nminus1,\r\n                                          pl_solution_nminus2,\r\n                                          Sa_solution_n,\r\n                                          Sa_solution_nminus1,\r\n                                          Sa_solution_nminus2,\r\n                                          Sv_solution_n,\r\n                                          Sv_solution_nminus1,\r\n                                          Sv_solution_nminus2);\r\n            timer.stop();\r\n\r\n            assemble_time[index_time] = timer.cpu_time();\r\n            pcout << \"Elapsed CPU time for pl assemble: \" << timer.cpu_time() << \" seconds.\" << std::endl;\r\n\r\n            // solve for pl\r\n            timer.reset();\r\n            timer.start();\r\n            pl_problem.solve_pressure();\r\n            timer.stop();\r\n\r\n            solver_time[index_time] = timer.cpu_time();\r\n            pcout << \"Elapsed CPU time for pl solve: \" << timer.cpu_time() << \" seconds.\" << std::endl;\r\n\r\n            //store solution\r\n            pl_solution = pl_problem.pl_solution;\r\n\r\n            // Project to appropriate RT space depending on user input\r\n            if (project_to_RT0)\r\n            {\r\n                if (project_Darcy_with_gravity)\r\n                    {\r\n                        totalDarcyvelocity_RT_Sa = RT_Projection::compute_RT0_projection_with_gravity(triangulation,\r\n                                                                                                      degree, theta_pl,\r\n                                                                                                      time, time_step,\r\n                                                                                                      penalty_pl,\r\n                                                                                                      penalty_pl_bdry,\r\n                                                                                                      dirichlet_id_pl,\r\n                                                                                                      use_exact_pl_in_RT,\r\n                                                                                                      use_exact_Sa_in_RT,\r\n                                                                                                      use_exact_Sv_in_RT,\r\n                                                                                                      second_order_extrapolation,\r\n                                                                                                      incompressible,\r\n                                                                                                      pl_solution,\r\n                                                                                                      Sa_solution_n,\r\n                                                                                                      Sa_solution_nminus1,\r\n                                                                                                      Sv_solution_n,\r\n                                                                                                      Sv_solution_nminus1,\r\n                                                                                                      kappa_abs_vec,\r\n                                                                                                      true,\r\n                                                                                                      project_only_kappa,\r\n                                                                                                      mpi_communicator,\r\n                                                                                                      n_mpi_processes,\r\n                                                                                                      this_mpi_process);\r\n\r\n                        totalDarcyvelocity_RT_Sv = RT_Projection::compute_RT0_projection_with_gravity(triangulation,\r\n                                                                                                      degree, theta_pl,\r\n                                                                                                      time, time_step,\r\n                                                                                                      penalty_pl,\r\n                                                                                                      penalty_pl_bdry,\r\n                                                                                                      dirichlet_id_pl,\r\n                                                                                                      use_exact_pl_in_RT,\r\n                                                                                                      use_exact_Sa_in_RT,\r\n                                                                                                      use_exact_Sv_in_RT,\r\n                                                                                                      second_order_extrapolation,\r\n                                                                                                      incompressible,\r\n                                                                                                      pl_solution,\r\n                                                                                                      Sa_solution_n,\r\n                                                                                                      Sa_solution_nminus1,\r\n                                                                                                      Sv_solution_n,\r\n                                                                                                      Sv_solution_nminus1,\r\n                                                                                                      kappa_abs_vec,\r\n                                                                                                      false,\r\n                                                                                                      project_only_kappa,\r\n                                                                                                      mpi_communicator,\r\n                                                                                                      n_mpi_processes,\r\n                                                                                                      this_mpi_process);\r\n                    } else {\r\n                        totalDarcyvelocity_RT_Sa = RT_Projection::compute_RT0_projection<dim>(triangulation, degree,\r\n                                                                                              theta_pl, time,\r\n                                                                                              time_step, penalty_pl,\r\n                                                                                              penalty_pl_bdry,\r\n                                                                                              dirichlet_id_pl,\r\n                                                                                              use_exact_pl_in_RT,\r\n                                                                                              use_exact_Sa_in_RT,\r\n                                                                                              use_exact_Sv_in_RT,\r\n                                                                                              second_order_extrapolation,\r\n                                                                                              incompressible,\r\n                                                                                              pl_solution,\r\n                                                                                              Sa_solution_n,\r\n                                                                                              Sa_solution_nminus1,\r\n                                                                                              Sv_solution_n,\r\n                                                                                              Sv_solution_nminus1,\r\n                                                                                              kappa_abs_vec,\r\n                                                                                              project_only_kappa,\r\n                                                                                              mpi_communicator,\r\n                                                                                              n_mpi_processes,\r\n                                                                                              this_mpi_process);\r\n\r\n                        totalDarcyvelocity_RT_Sv = totalDarcyvelocity_RT_Sa;\r\n                    }\r\n\r\n            } else // Project to RTk\r\n                {\r\n                    if (project_Darcy_with_gravity)\r\n                    {\r\n                        totalDarcyvelocity_RT_Sa = RT_Projection::compute_RTk_projection_with_gravity<dim>(\r\n                                triangulation, degree, theta_pl, time,\r\n                                time_step, penalty_pl, penalty_pl_bdry, dirichlet_id_pl, use_exact_pl_in_RT,\r\n                                use_exact_Sa_in_RT, use_exact_Sv_in_RT, second_order_extrapolation, incompressible,\r\n                                pl_solution, Sa_solution_n, Sa_solution_nminus1,\r\n                                Sv_solution_n, Sv_solution_nminus1, kappa_abs_vec,\r\n                                true, project_only_kappa, mpi_communicator, n_mpi_processes, this_mpi_process);\r\n\r\n                        totalDarcyvelocity_RT_Sv = RT_Projection::compute_RTk_projection_with_gravity<dim>(\r\n                                triangulation, degree, theta_pl, time,\r\n                                time_step, penalty_pl, penalty_pl_bdry, dirichlet_id_pl, use_exact_pl_in_RT,\r\n                                use_exact_Sa_in_RT, use_exact_Sv_in_RT, second_order_extrapolation, incompressible,\r\n                                pl_solution, Sa_solution_n, Sa_solution_nminus1,\r\n                                Sv_solution_n, Sv_solution_nminus1, kappa_abs_vec,\r\n                                false, project_only_kappa, mpi_communicator, n_mpi_processes, this_mpi_process);\r\n                    }\r\n                    else\r\n                    {\r\n                        totalDarcyvelocity_RT_Sa = RT_Projection::compute_RTk_projection<dim>(triangulation, degree,\r\n                                                                                              theta_pl, time,\r\n                                                                                              time_step, penalty_pl,\r\n                                                                                              penalty_pl_bdry,\r\n                                                                                              dirichlet_id_pl,\r\n                                                                                              use_exact_pl_in_RT,\r\n                                                                                              use_exact_Sa_in_RT,\r\n                                                                                              use_exact_Sv_in_RT,\r\n                                                                                              second_order_extrapolation,\r\n                                                                                              incompressible,\r\n                                                                                              pl_solution,\r\n                                                                                              Sa_solution_n,\r\n                                                                                              Sa_solution_nminus1,\r\n                                                                                              Sv_solution_n,\r\n                                                                                              Sv_solution_nminus1,\r\n                                                                                              kappa_abs_vec,\r\n                                                                                              project_only_kappa,\r\n                                                                                              mpi_communicator,\r\n                                                                                              n_mpi_processes,\r\n                                                                                              this_mpi_process);\r\n                        totalDarcyvelocity_RT_Sv = totalDarcyvelocity_RT_Sa;\r\n                    }\r\n                }\r\n\r\n            timer.stop();\r\n            RTproj_time[index_time] = timer.cpu_time();\r\n            pcout << \"Elapsed CPU time for RT Projection: \" << timer.cpu_time() << \" seconds.\" << std::endl;\r\n\r\n            totalDarcyvelocity_RT_Sa_n = totalDarcyvelocity_RT_Sa;\r\n            totalDarcyvelocity_RT_Sv_n = totalDarcyvelocity_RT_Sv;\r\n\r\n            pcout << std::endl;\r\n\r\n                    timer.reset();\r\n                    timer.start();\r\n            Sa_problem.assemble_system_Sa(time_step,\r\n                                          time, timestep_number, rebuild_Sa_mat,\r\n                                          pl_solution, pl_solution_n, pl_solution_nminus1,\r\n                                          Sa_solution_n, Sa_solution_nminus1,\r\n                                          Sv_solution_n, Sv_solution_nminus1,\r\n                                          totalDarcyvelocity_RT_Sa);\r\n            timer.stop();\r\n            pcout << \"Elapsed CPU time for Sa system assemble: \" << timer.cpu_time() << \" seconds.\" << std::endl;\r\n\r\n\r\n            // Solve for Sa\r\n            timer.reset();\r\n            timer.start();\r\n            Sa_problem.solve_aqueous_saturation(pl_solution);\r\n            timer.stop();\r\n            pcout << \"Elapsed CPU time for Sa solve \" << timer.cpu_time() << \" seconds.\" << std::endl;\r\n            Sa_solution = Sa_problem.Sa_solution;\r\n\r\n            if (Stab_a) {\r\n                rebuild_Sa_mat = false;\r\n            }\r\n            // stop here for two phase\r\n            if (two_phase)\r\n                Sv_solution = 0.0;\r\n\r\n            // else start solving for Sv\r\n            else\r\n            {\r\n                // Assemble system for Sv\r\n                timer.reset();\r\n                timer.start();\r\n                Sv_problem.assemble_system_Sv(time_step,time,timestep_number,rebuild_Sv_mat,\r\n                                                                   pl_solution, pl_solution_n, pl_solution_nminus1,\r\n                                                                   Sa_solution, Sa_solution_n, Sa_solution_nminus1,\r\n                                                                   Sv_solution_n, Sv_solution_nminus1,totalDarcyvelocity_RT_Sv);\r\n                timer.stop();\r\n\r\n                assemble_time[index_time] += timer.cpu_time();\r\n                pcout << std::endl;\r\n                pcout << \"Elapsed CPU time for Sv assemble: \" << timer.cpu_time() << \" seconds.\" << std::endl;\r\n\r\n                // Solve for Sv\r\n                timer.reset();\r\n                timer.start();\r\n                Sv_problem.solve_vapor_saturation(pl_solution);\r\n                timer.stop();\r\n\r\n                solver_time[index_time] += timer.cpu_time();\r\n                pcout << \"Elapsed CPU time for Sv solve: \" << timer.cpu_time() << \" seconds.\" << std::endl;\r\n\r\n                // Store solution for Sv\r\n                Sv_solution = Sv_problem.Sv_solution;\r\n\r\n\t\t\t\tif (Stab_v)\r\n\t\t   \t\t\trebuild_Sv_mat = false;\r\n            }\r\n\r\n            pl_solution_nminus2 = pl_solution_nminus1;\r\n            pl_solution_nminus1 = pl_solution_n;\r\n            pl_solution_n = pl_solution;\r\n\r\n            Sa_solution_nminus2 = Sa_solution_nminus1;\r\n            Sa_solution_nminus1 = Sa_solution_n;\r\n            Sa_solution_n = Sa_solution;\r\n\r\n            Sv_solution_nminus2 = Sv_solution_nminus1;\r\n            Sv_solution_nminus1 = Sv_solution_n;\r\n            Sv_solution_n = Sv_solution;\r\n\r\n            timer.reset();\r\n            timer.start();\r\n            if (print_vtk && timestep_number % vtk_freq == 0)\r\n                output_vtk();\r\n            if (output_sol && timestep_number % output_sol_freq == 0)\r\n                output_solution();\r\n            timer.stop();\r\n            pcout << \"Elapsed CPU time for output results: \" << timer.cpu_time() << \" seconds.\" << std::endl;\r\n            pcout << std::endl;\r\n\r\n            totalDarcyvelocity_RT_Sa_n = totalDarcyvelocity_RT_Sa;\r\n            totalDarcyvelocity_RT_Sa = 0.0;\r\n\r\n            totalDarcyvelocity_RT_Sv_n = totalDarcyvelocity_RT_Sv;\r\n            totalDarcyvelocity_RT_Sv = 0.0;\r\n\r\n\r\n            double real_energy, num_energy;\r\n\r\n            if (compute_energy) {\r\n                num_energy = calculate_energy(real_energy);\r\n                energy_file << num_energy << \" \" << real_energy;\r\n                energy_file << std::endl;\r\n            }\r\n\r\n        }\r\n\r\n        ExactLiquidPressure<dim> exact_solution_pressure;\r\n        exact_solution_pressure.set_time(time);\r\n        Vector<double> cellwise_errors_pl2(triangulation.n_active_cells());\r\n\r\n        ExactAqueousSaturation<dim> exact_solution_aqueous_saturation;\r\n        exact_solution_aqueous_saturation.set_time(time);\r\n        Vector<double> cellwise_errors_Sa2(triangulation.n_active_cells());\r\n\r\n        QTrapezoid<1> q_trapez2;\r\n        QIterated<dim> quadrature2(q_trapez2, degree + 2);\r\n\r\n        VectorTools::integrate_difference(dof_handler,\r\n                                          pl_solution,\r\n                                          exact_solution_pressure,\r\n                                          cellwise_errors_pl2,\r\n                                          quadrature2,\r\n                                          VectorTools::L2_norm);\r\n        const double pl_l2_error =\r\n                VectorTools::compute_global_error(triangulation,\r\n                                                  cellwise_errors_pl2,\r\n                                                  VectorTools::L2_norm);\r\n\r\n        VectorTools::integrate_difference(dof_handler,\r\n                                          Sa_solution,\r\n                                          exact_solution_aqueous_saturation,\r\n                                          cellwise_errors_Sa2,\r\n                                          quadrature2,\r\n                                          VectorTools::L2_norm);\r\n        const double Sa_l2_error =\r\n                VectorTools::compute_global_error(triangulation,\r\n                                                  cellwise_errors_Sa2,\r\n                                                  VectorTools::L2_norm);\r\n\r\n        errors_file << pl_l2_error << \"  \" << Sa_l2_error << std::endl;\r\n        index_time++;\r\n\r\n        total_timer.stop();\r\n        total_time = total_timer.cpu_time();\r\n\r\n        // Save computation times\r\n        std::ofstream time_file;\r\n        time_file.open(\"times\");\r\n\r\n        time_file << \"Average assemble time = \" << assemble_time.mean_value() << std::endl;\r\n        time_file << \"Average solver time = \" << solver_time.mean_value() << std::endl;\r\n        time_file << \"Average RT Projection time = \" << RTproj_time.mean_value() << std::endl;\r\n        total_time /= index_time;\r\n        time_file << \"Average total time = \" << total_time << std::endl;\r\n\r\n        time_file.close();\r\n\r\n//    std::ofstream iter_file;\r\n//\titer_file.open(\"iterations\");\r\n\r\n//\titer_file << min_Sa_per_time;\r\n//\titer_file << std::endl;\r\n//\titer_file << max_Sa_per_time;\r\n\r\n        iter_file.close();\r\n\r\n        if (compute_errors_sol)\r\n            compute_errors();\r\n    }\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    try\r\n    {\r\n    \tUtilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv, 1);\r\n        ParameterHandler prm;\r\n        CouplingPressureSaturation::ParameterReader  param(prm);\r\n        param.read_parameters(\"parameters.prm\");\r\n\r\n        prm.enter_subsection(\"Time discretization parameters\");\r\n\r\n        double tf = prm.get_double(\"Final time\");\r\n\r\n        double init_delta_t = prm.get_double(\"Initial time step\");\r\n\r\n        prm.leave_subsection();\r\n\r\n        double delta_t = init_delta_t;\r\n\r\n        prm.enter_subsection(\"Spatial discretization parameters\");\r\n        int dimension = prm.get_integer(\"Dimension\");\r\n        const unsigned int fe_degree = prm.get_integer(\"Degree\");\r\n        const unsigned int init_refinement_level = prm.get_integer(\"Initial level of refinement\");\r\n        const unsigned int final_refinement_level = prm.get_integer(\"Final level of refinement\");\r\n        bool project_to_RT0 = prm.get_bool(\"Project to RT0\");\r\n        prm.leave_subsection();\r\n\r\n        unsigned int degreeRT;\r\n\t\tif(project_to_RT0)\r\n\t\t\tdegreeRT = 0;\r\n\t\telse\r\n\t\t\tdegreeRT = fe_degree;\r\n\r\n        for(unsigned int refinement_level = init_refinement_level; refinement_level <= final_refinement_level; refinement_level++)\r\n        {\r\n        \tif(dimension == 2)\r\n        \t{\r\n\t\t\t\tCouplingPressureSaturation::CoupledPressureSaturationProblem<2> dgmethod(fe_degree, degreeRT,\r\n\t\t\t\t\t\tdelta_t, tf, refinement_level, prm);\r\n\t\t\t\tdgmethod.run();\r\n        \t}\r\n        \telse if(dimension == 3)\r\n        \t{\r\n\t\t\t\tCouplingPressureSaturation::CoupledPressureSaturationProblem<3> dgmethod(fe_degree, degreeRT,\r\n\t\t\t\t\t\tdelta_t, tf, refinement_level, prm);\r\n\t\t\t\tdgmethod.run();\r\n        \t}\r\n\r\n\t\t\tdelta_t /= 4.0;\r\n        }\r\n    }\r\n    catch (std::exception &exc)\r\n    {\r\n        std::cerr << std::endl\r\n                  << std::endl\r\n                  << \"----------------------------------------------------\"\r\n                  << std::endl;\r\n        std::cerr << \"Exception on processing: \" << std::endl\r\n                  << exc.what() << std::endl\r\n                  << \"Aborting!\" << std::endl\r\n                  << \"----------------------------------------------------\"\r\n                  << std::endl;\r\n        return 1;\r\n    }\r\n    catch (...)\r\n    {\r\n        std::cerr << std::endl\r\n                  << std::endl\r\n                  << \"----------------------------------------------------\"\r\n                  << std::endl;\r\n        std::cerr << \"Unknown exception!\" << std::endl\r\n                  << \"Aborting!\" << std::endl\r\n                  << \"----------------------------------------------------\"\r\n                  << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ThreePhase.cc b/ThreePhase.cc
--- a/ThreePhase.cc	(revision 33378f0ea2279a05e7c4152639d8e85150230c5d)
+++ b/ThreePhase.cc	(date 1737125892555)
@@ -820,7 +820,7 @@
     template<int dim>
     void CoupledPressureSaturationProblem<dim>::output_vtk_initial_cond() const {
         DataOutBase::VtkFlags flags;
-        flags.compression_level = DataOutBase::VtkFlags::best_speed;
+        //flags.compression_level = DataOutBase::VtkFlags::best_speed;
 
         // To print kappa_abs vector
         kappa_abs_vec.update_ghost_values();
@@ -923,7 +923,7 @@
     template<int dim>
     void CoupledPressureSaturationProblem<dim>::output_vtk() const {
         DataOutBase::VtkFlags flags;
-        flags.compression_level = DataOutBase::VtkFlags::best_speed;
+        //flags.compression_level = DataOutBase::VtkFlags::best_speed;
 
         pl_solution.update_ghost_values();
 

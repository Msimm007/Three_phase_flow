diff --git a/Sa_problem.hh b/Sa_problem.hh
index 5828267..fb3332e 100644
--- a/Sa_problem.hh
+++ b/Sa_problem.hh
@@ -29,41 +29,52 @@
 #include <deal.II/base/tensor_product_polynomials.h>
 #include <deal.II/base/polynomial.h>
 #include <deal.II/fe/fe_face.h>
+
 #include <deal.II/base/conditional_ostream.h>
 #include <deal.II/base/mpi.h>
+
 #include <deal.II/grid/grid_tools.h>
 #include <deal.II/dofs/dof_renumbering.h>
+
 #include <deal.II/meshworker/mesh_loop.h>
 #include <deal.II/meshworker/scratch_data.h>
 #include <deal.II/base/parameter_handler.h>
+
 #include "AverageGradientOperators.hh"
+
+// PETSc stuff
 #include <deal.II/lac/petsc_vector.h>
 #include <deal.II/lac/petsc_sparse_matrix.h>
 #include <deal.II/lac/petsc_solver.h>
 #include <deal.II/lac/petsc_precondition.h>
+
 #include <iostream>
 #include <fstream>
 #include <algorithm>
-#include <utility>
 
 namespace AqueousSaturation
 {
     using namespace dealii;
 
-
     struct CopyDataFace
     {
         FullMatrix<double>                   cell_matrix;
         Vector<double>                       cell_rhs;
         std::vector<types::global_dof_index> joint_dof_indices;
+        std::array<unsigned int, 2>          cell_indices;
+        std::array<double, 2>                values;
     };
 
+
+
     struct CopyData
     {
         FullMatrix<double>                   cell_matrix;
         Vector<double>                       cell_rhs;
         std::vector<types::global_dof_index> local_dof_indices;
         std::vector<CopyDataFace>            face_data;
+        double                               value;
+        unsigned int                         cell_index;
 
         template <class Iterator>
         void reinit_matrix(const Iterator &cell, unsigned int dofs_per_cell)
@@ -86,48 +97,31 @@ namespace AqueousSaturation
     {
     public:
         AqueousSaturationProblem(Triangulation<dim, dim> &triangulation_,
-                                 unsigned int degree_,
-                                 double theta_Sa_,
-                                 double penalty_Sa_,
-                                 double penalty_Sa_bdry_,
-                                 std::vector<unsigned int> dirichlet_id_sa_,
-                                 bool use_exact_pl_in_Sa_,
+                                 const unsigned int degree_, double theta_Sa_, double penalty_Sa_,
+                                 double penalty_Sa_bdry_, std::vector<unsigned int> dirichlet_id_sa_, bool use_exact_pl_in_Sa_,
                                  bool use_exact_Sv_in_Sa_,
-                                 bool second_order_time_derivative_,
-                                 bool second_order_extrapolation_,
-                                 bool use_direct_solver_,
-                                 bool Stab_a_,
-                                 bool incompressible_,
-                                 bool project_Darcy_with_gravity_,
-                                 bool artificial_visc_exp_,
-                                 bool artificial_visc_imp_,
+                                 bool second_order_time_derivative_, bool second_order_extrapolation_,
+                                 bool use_direct_solver_,bool Stab_a_, bool incompressible_, bool project_Darcy_with_gravity_,
+                                 bool artificial_visc_exp_, bool artificial_visc_imp_,
                                  double art_visc_multiple_Sa_,
                                  PETScWrappers::MPI::Vector kappa_abs_vec_,
-                                 unsigned int degreeRT_,
-                                 bool project_only_kappa_,
-                                 MPI_Comm mpi_communicator_,
-                                 unsigned int n_mpi_processes_,
-                                 unsigned int this_mpi_process_);
-
-        void assemble_system_Sa(double time_step_,
-                                double time_,
+                                 const unsigned int degreeRT_, bool project_only_kappa_,
+                                 MPI_Comm mpi_communicator_, const unsigned int n_mpi_processes_, const unsigned int this_mpi_process_);
+
+        void setup_system();
+
+        void assemble_system_matrix_aqueous_saturation(double time_step_,double time_,
                                          unsigned int timestep_number_,
                                          bool rebuild_matrix_,
-                                const PETScWrappers::MPI::Vector& pl_solution_,
-                                const PETScWrappers::MPI::Vector& pl_solution_n_,
-                                const PETScWrappers::MPI::Vector& pl_solution_nminus1_,
-                                const PETScWrappers::MPI::Vector& Sa_solution_n_,
-                                const PETScWrappers::MPI::Vector& Sa_solution_nminus1_,
-                                const PETScWrappers::MPI::Vector& Sv_solution_n_,
-                                const PETScWrappers::MPI::Vector& Sv_solution_nminus1_,
-                                const PETScWrappers::MPI::Vector& totalDarcyvelocity_RT_);
+                                         PETScWrappers::MPI::Vector pl_solution_, PETScWrappers::MPI::Vector pl_solution_n_,
+                                         PETScWrappers::MPI::Vector pl_solution_nminus1_,
+                                         PETScWrappers::MPI::Vector Sa_solution_n_, PETScWrappers::MPI::Vector Sa_solution_nminus1_,
+                                         PETScWrappers::MPI::Vector Sv_solution_n_, PETScWrappers::MPI::Vector Sv_solution_nminus1_,
+                                         PETScWrappers::MPI::Vector totalDarcyvelocity_RT_);
                                           
-        void solve_aqueous_saturation(const PETScWrappers::MPI::Vector& pl_solution_);
+        void solve_aqueous_saturation(PETScWrappers::MPI::Vector pl_solution_);
 
         PETScWrappers::MPI::Vector Sa_solution;
-        void setup_system();
-
-
     private:
 
         parallel::shared::Triangulation<dim>   triangulation;
@@ -212,32 +206,22 @@ namespace AqueousSaturation
         DoFHandler<dim> dof_handler_RT;
 
         AffineConstraints<double> constraints;
+
     };
 
+
     template <int dim>
     AqueousSaturationProblem<dim>::AqueousSaturationProblem(Triangulation<dim, dim> &triangulation_,
-                                                            const unsigned int degree_,
-                                                            double theta_Sa_,
-                                                            double penalty_Sa_,
-                                                            double penalty_Sa_bdry_,
-                                                            std::vector<unsigned int> dirichlet_id_sa_,
-                                                            bool use_exact_pl_in_Sa_,
+                                    const unsigned int degree_,  double theta_Sa_, double penalty_Sa_,
+                                    double penalty_Sa_bdry_, std::vector<unsigned int> dirichlet_id_sa_, bool use_exact_pl_in_Sa_,
                                     bool use_exact_Sv_in_Sa_, 
-                                                            bool second_order_time_derivative_,
-                                                            bool second_order_extrapolation_,
-                                                            bool use_direct_solver_,
-                                                            bool Stab_a_,
-                                                            bool incompressible_,
-                                                            bool project_Darcy_with_gravity_,
-                                                            bool artificial_visc_exp_,
-                                                            bool artificial_visc_imp_,
+                                    bool second_order_time_derivative_, bool second_order_extrapolation_,
+                                    bool use_direct_solver_, bool Stab_a_, bool incompressible_, bool project_Darcy_with_gravity_,
+                                    bool artificial_visc_exp_, bool artificial_visc_imp_,
                                     double art_visc_multiple_Sa_,
                                     PETScWrappers::MPI::Vector kappa_abs_vec_,
-                                                            const unsigned int degreeRT_,
-                                                            bool project_only_kappa_,
-                                                            MPI_Comm mpi_communicator_,
-                                                            const unsigned int n_mpi_processes_,
-                                                            const unsigned int this_mpi_process_)
+                                    const unsigned int degreeRT_, bool project_only_kappa_,
+                                    MPI_Comm mpi_communicator_, const unsigned int n_mpi_processes_, const unsigned int this_mpi_process_)
             : triangulation(MPI_COMM_WORLD)
             , mapping()
             , degree(degree_)
@@ -249,7 +233,7 @@ namespace AqueousSaturation
             , theta_Sa(theta_Sa_)
             , penalty_Sa(penalty_Sa_)
             , penalty_Sa_bdry(penalty_Sa_bdry_)
-            , dirichlet_id_sa(std::move(dirichlet_id_sa_))
+            , dirichlet_id_sa(dirichlet_id_sa_)
             , use_exact_pl_in_Sa(use_exact_pl_in_Sa_)
             , use_exact_Sv_in_Sa(use_exact_Sv_in_Sa_)
             , second_order_time_derivative(second_order_time_derivative_)
@@ -309,37 +293,27 @@ namespace AqueousSaturation
     }
 
     template <int dim>
-    void AqueousSaturationProblem<dim>::
-    assemble_system_Sa(double time_step_,
-                       double time_,
-                       unsigned int timestep_number_,
-                       bool rebuild_matrix_,
-                       const PETScWrappers::MPI::Vector& pl_solution_,
-                       const PETScWrappers::MPI::Vector& pl_solution_n_,
-                       const PETScWrappers::MPI::Vector& pl_solution_nminus1_,
-                       const PETScWrappers::MPI::Vector& Sa_solution_n_,
-                       const PETScWrappers::MPI::Vector& Sa_solution_nminus1_,
-                       const PETScWrappers::MPI::Vector& Sv_solution_n_,
-                       const PETScWrappers::MPI::Vector& Sv_solution_nminus1_,
-                       const PETScWrappers::MPI::Vector& totalDarcyvelocity_RT_)
+    void AqueousSaturationProblem<dim>::assemble_system_matrix_aqueous_saturation(double time_step_, double time_,unsigned int timestep_number_,bool rebuild_matrix_,
+                                     PETScWrappers::MPI::Vector pl_solution_, PETScWrappers::MPI::Vector pl_solution_n_,
+                                     PETScWrappers::MPI::Vector pl_solution_nminus1_,
+                                     PETScWrappers::MPI::Vector Sa_solution_n_, PETScWrappers::MPI::Vector Sa_solution_nminus1_,
+                                     PETScWrappers::MPI::Vector Sv_solution_n_, PETScWrappers::MPI::Vector Sv_solution_nminus1_,
+                                     PETScWrappers::MPI::Vector totalDarcyvelocity_RT_)
     {
-
-        // Update rebuild_matrix
         rebuild_matrix = rebuild_matrix_;
 
-        // reinit LHS matrix
-        if (rebuild_matrix)
-        {
+        if (rebuild_matrix){
+            
         system_matrix_aqueous_saturation.reinit(locally_owned_dofs,
                                                 locally_owned_dofs,
                                                 sparsity_pattern,
                                                 mpi_communicator);
         }
 
-        // reinit RHS vector
+                                                
         right_hand_side_aqueous_saturation.reinit(locally_owned_dofs, mpi_communicator);
 
-        // Update time terms
+        //time terms
         time_step = time_step_;
         time = time_;
         timestep_number = timestep_number_;
@@ -386,8 +360,8 @@ namespace AqueousSaturation
         lambda_a<dim> lambda_a_fcn;
 
         // Stabilization term. Declared and defined
-        StabAqueousSaturation<dim> kappa_tilde_a_fcn;
-        double kappa_tilde_a = kappa_tilde_a_fcn.value();
+        Kappa_tilde_a<dim> Kappa_tilde_a_fcn;
+        double Kappa_tilde_a = Kappa_tilde_a_fcn.value();
 
         // Capillary pressures
         CapillaryPressurePca<dim> cap_p_pca_fcn;
@@ -470,13 +444,16 @@ namespace AqueousSaturation
 
             const unsigned int n_dofs = fe_v.dofs_per_cell;
 
-            if (rebuild_matrix)
-            {
+            // reinit used here for copy data
+            if (rebuild_matrix){
+
                 copy_data.reinit_matrix(cell, n_dofs);
+
             }
             
             copy_data.reinit_rhs(cell, n_dofs);
             
+
             const auto &q_points = fe_v.get_quadrature_points();
             const int n_qpoints = q_points.size();
 
@@ -487,9 +464,7 @@ namespace AqueousSaturation
                                        update_values);
 
             typename DoFHandler<dim>::cell_iterator cell_RT(&triangulation,
-                                                            cell->level(),
-                                                            cell->index(),
-                                                            &dof_handler_RT);
+                                                            cell->level(), cell->index(), &dof_handler_RT);
 
             fe_values_RT.reinit(cell_RT);
 
@@ -542,10 +517,8 @@ namespace AqueousSaturation
                 linf_norm_Darcy_vel[kk] = darcy_v.linfty_norm();
             }
 
-            double maximum_Darcy = *std::max_element(linf_norm_Darcy_vel.begin(),
-                                                     linf_norm_Darcy_vel.end());
-            double maximum_Sa = *std::max_element(old_Sa_vals.begin(),
-                                                  old_Sa_vals.end());
+            double maximum_Darcy = *std::max_element(linf_norm_Darcy_vel.begin(), linf_norm_Darcy_vel.end());
+            double maximum_Sa = *std::max_element(old_Sa_vals.begin(), old_Sa_vals.end());
 
             double kappa = temp_kappa[cell->global_active_cell_index()];
 
@@ -614,6 +587,7 @@ namespace AqueousSaturation
 
                     Sv_grad_nplus1_extrapolation *= 2.0;
                     Sv_grad_nplus1_extrapolation -= Sv_grad_nminus1;
+
                 }
 
                 // Coefficient values
@@ -622,9 +596,7 @@ namespace AqueousSaturation
                 double phi_nminus1 = porosity_fcn.value(pl_value_nminus1);
 
                 double rho_l = rho_l_fcn.value(pl_value);
-                double rho_v = rho_v_fcn.value(pl_value,
-                                               Sa_nplus1_extrapolation,
-                                               Sv_nplus1_extrapolation);
+                double rho_v = rho_v_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
                 double rho_a = rho_a_fcn.value(pl_value);
 
                 double rho_a_n = rho_a_fcn.value(pl_value_n);
@@ -637,28 +609,21 @@ namespace AqueousSaturation
                     rho_a_nminus1 = 1.0;
                 }
 
-                double lambda_l = lambda_l_fcn.value(pl_value,
-                                                     Sa_nplus1_extrapolation,
-                                                     Sv_nplus1_extrapolation);
-                double lambda_v = lambda_v_fcn.value(pl_value,
-                                                     Sa_nplus1_extrapolation,
-                                                     Sv_nplus1_extrapolation);
-                double lambda_a = lambda_a_fcn.value(pl_value,
-                                                     Sa_nplus1_extrapolation,
-                                                     Sv_nplus1_extrapolation);
+                double lambda_l = lambda_l_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
+                double lambda_v = lambda_v_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
+                double lambda_a = lambda_a_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
+
                 double rholambda_t = rho_l*lambda_l + rho_v*lambda_v + rho_a*lambda_a;
 
-                double dpca_dSa = cap_p_pca_fcn.derivative_wrt_Sa(Sa_nplus1_extrapolation,
-                                                                  Sv_nplus1_extrapolation);
-                double dpca_dSv = cap_p_pca_fcn.derivative_wrt_Sv(Sa_nplus1_extrapolation,
-                                                                  Sv_nplus1_extrapolation);
+                double dpca_dSa = cap_p_pca_fcn.derivative_wrt_Sa(Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
+                double dpca_dSv = cap_p_pca_fcn.derivative_wrt_Sv(Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
 
                 // Artificial viscosity stuff. This is not fully tested/working
                 double nu_h_artificial_visc = 0.0;
                 if(artificial_visc_exp || artificial_visc_imp)
-                    nu_h_artificial_visc = 0.5*sqrt(cell->measure())
-                                           *art_visc_multiple_Sa*maximum_Darcy*2.0*maximum_Sa;
-                // start of volume terms 
+                    nu_h_artificial_visc = 0.5*sqrt(cell->measure())*art_visc_multiple_Sa*maximum_Darcy*2.0*maximum_Sa;
+
+                // This is where the main formulation starts
                 for (unsigned int i = 0; i < n_dofs; ++i)
                 {
                     if (rebuild_matrix)
@@ -691,7 +656,7 @@ namespace AqueousSaturation
                             {
                             // Diffusion Term
                             copy_data.cell_matrix(i,j) -=
-                                        -kappa_tilde_a
+                                    -Kappa_tilde_a
                                     * kappa
                                     * fe_v.shape_grad(i, point)
                                     * fe_v.shape_grad(j, point)
@@ -720,14 +685,12 @@ namespace AqueousSaturation
                         }
                     }
                     // Source term
-                    copy_data.cell_rhs(i) += right_hand_side_fcn.value(q_points[point])
-                                             * fe_v.shape_value(i, point) * JxW[point];
+                    copy_data.cell_rhs(i) += right_hand_side_fcn.value(q_points[point]) * fe_v.shape_value(i, point) * JxW[point];
 
                     // Time term
                     if(timestep_number == 1 || !second_order_time_derivative) // bdf1
                     {
-                        copy_data.cell_rhs(i) += (1.0/time_step)
-                                                 * phi_n * rho_a_n * Sa_value_n
+                        copy_data.cell_rhs(i) += (1.0/time_step) * phi_n * rho_a_n * Sa_value_n
                                                  * fe_v.shape_value(i, point) * JxW[point];
                     }
                     else // bdf2
@@ -738,20 +701,15 @@ namespace AqueousSaturation
                                                  * fe_v.shape_value(i, point) * JxW[point];
                     }
 
-                    // this is the SV term
-                    copy_data.cell_rhs(i) += rho_a * lambda_a * dpca_dSv
-                                             * kappa * Sv_grad_nplus1_extrapolation
+                    copy_data.cell_rhs(i) += rho_a * lambda_a * dpca_dSv * kappa * Sv_grad_nplus1_extrapolation
                                              * fe_v.shape_grad(i, point) * JxW[point];
 
-                    // Diffusion term moved to RHS - stab method
                     if(Stab_a)
                     {
-                        copy_data.cell_rhs(i) += (rho_a * lambda_a * dpca_dSa + kappa_tilde_a)
-                                                 * kappa * Sa_grad_n
+                        copy_data.cell_rhs(i) += (rho_a * lambda_a * dpca_dSa + Kappa_tilde_a) * kappa * Sa_grad_n
                                                  * fe_v.shape_grad(i, point) * JxW[point];
 
                     }
-
                     // Darcy term. Coefficient depends on what was projected
                     if(project_only_kappa)
                     {
@@ -775,8 +733,10 @@ namespace AqueousSaturation
                                                  * Sa_grad_n
                                                  * fe_v.shape_grad(i, point)
                                                  * JxW[point];
+
                 }
             }
+
         };
 
         // Boundary face integrals
@@ -795,9 +755,7 @@ namespace AqueousSaturation
                                                 update_values);
 
             typename DoFHandler<dim>::cell_iterator cell_RT(&triangulation,
-                                                            cell->level(),
-                                                            cell->index(),
-                                                            &dof_handler_RT);
+                                                            cell->level(), cell->index(), &dof_handler_RT);
 
             fe_face_values_RT.reinit(cell_RT, face_no);
 
@@ -855,10 +813,8 @@ namespace AqueousSaturation
                 linf_norm_Darcy_vel[kk] = darcy_v.linfty_norm();
             }
 
-            double maximum_Darcy = *std::max_element(linf_norm_Darcy_vel.begin(),
-                                                     linf_norm_Darcy_vel.end());
-            double maximum_Sa = *std::max_element(old_Sa_vals.begin(),
-                                                  old_Sa_vals.end());
+            double maximum_Darcy = *std::max_element(linf_norm_Darcy_vel.begin(), linf_norm_Darcy_vel.end());
+            double maximum_Sa = *std::max_element(old_Sa_vals.begin(), old_Sa_vals.end());
 
             double kappa = temp_kappa[cell->global_active_cell_index()];
 
@@ -888,6 +844,7 @@ namespace AqueousSaturation
 
                         pl_value = pl_fcn.value(q_points[point]);
                         pl_grad = pl_fcn.gradient(q_points[point]);
+
                     }
 
                     double Sa_value_n = old_Sa_vals[point];
@@ -929,6 +886,7 @@ namespace AqueousSaturation
 
                         Sv_grad_nplus1_extrapolation *= 2.0;
                         Sv_grad_nplus1_extrapolation -= Sv_grad_nminus1;
+
                     }
 
                     // Coefficients
@@ -945,9 +903,14 @@ namespace AqueousSaturation
                     double lambda_v = lambda_v_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
                     double lambda_a = lambda_a_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
 
+//				double lambda_l = lambda_l_fcn.value(g_pl[point], g[point], Sv_nplus1_extrapolation);
+//				double lambda_v = lambda_v_fcn.value(g_pl[point], g[point], Sv_nplus1_extrapolation);
+//				double lambda_a = lambda_a_fcn.value(g_pl[point], g[point], Sv_nplus1_extrapolation);
+
                     double rholambda_t = rho_l*lambda_l + rho_v*lambda_v + rho_a*lambda_a;
 
                     double dpca_dSa = cap_p_pca_fcn.derivative_wrt_Sa(Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
+//				    double dpca_dSa = cap_p_pca_fcn.derivative_wrt_Sa(g[point], Sv_nplus1_extrapolation);
                     double dpca_dSv = cap_p_pca_fcn.derivative_wrt_Sv(Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
 
                     double nu_h_artificial_visc = 0.0;
@@ -957,7 +920,7 @@ namespace AqueousSaturation
                     double gamma_Sa_e;
                     if (Stab_a)
                     {
-                        gamma_Sa_e = fabs(kappa_tilde_a*kappa);
+                        gamma_Sa_e = fabs(Kappa_tilde_a*kappa);
                     }
                     else
                     {
@@ -965,14 +928,12 @@ namespace AqueousSaturation
 
                     }
 
-                    if (artificial_visc_imp){
-
+                    if(artificial_visc_imp)
                         gamma_Sa_e += nu_h_artificial_visc;
                     
+                    if (!Stab_a){
+                    gamma_Sa_e += sqrt(totalDarcyVelo_extrapolation*totalDarcyVelo_extrapolation);
                     }
-                    // This is the problematic term. Commenting it out for now.
-                    // NECESSARY FOR VISCOUS FINGERING
-                    //gamma_Sa_e += sqrt(totalDarcyVelo_extrapolation*totalDarcyVelo_extrapolation);
 
                     double h_e = cell->face(face_no)->measure();
                     double penalty_factor = (penalty_Sa_bdry/h_e) * gamma_Sa_e * degree*(degree + dim - 1);
@@ -988,7 +949,7 @@ namespace AqueousSaturation
                                 {
                                 // Diffusion term
                                 copy_data.cell_matrix(i, j) -=
-                                           kappa_tilde_a
+                                        Kappa_tilde_a
                                         * kappa
                                         * fe_face.shape_value(i, point)
                                         * fe_face.shape_grad(j, point)
@@ -996,7 +957,7 @@ namespace AqueousSaturation
                                         * JxW[point];
                                 // Theta term
                                 copy_data.cell_matrix(i, j) +=
-                                           kappa_tilde_a
+                                        Kappa_tilde_a
                                         * kappa
                                         * theta_Sa
                                         * fe_face.shape_grad(i, point)
@@ -1016,7 +977,6 @@ namespace AqueousSaturation
                                         * fe_face.shape_grad(j, point)
                                         * normals[point]
                                         * JxW[point];
-
                                 //Theta term
                                 copy_data.cell_matrix(i, j) +=
                                          -rho_a
@@ -1029,7 +989,6 @@ namespace AqueousSaturation
                                         * fe_face.shape_value(j, point)
                                         * JxW[point];
                                 }
-
                                 // Not fully tested/working
                                 if(artificial_visc_imp)
                                 {
@@ -1049,7 +1008,7 @@ namespace AqueousSaturation
                                         * JxW[point];
                                 }
 
-                                // Boundary condition // CHANING IT
+                                // Boundary condition
                                 copy_data.cell_matrix(i, j) +=
                                     penalty_factor
                                     * fe_face.shape_value(i, point)
@@ -1057,26 +1016,25 @@ namespace AqueousSaturation
                                     * JxW[point];
                             }
                         }
+
                         // Boundary condition
                         copy_data.cell_rhs(i) += penalty_factor
                                                  * fe_face.shape_value(i, point)
                                                  * g[point]
                                                  * JxW[point];
-
                         // added to RHS - stab method
                         if (Stab_a)
                         {
                             copy_data.cell_rhs(i) -= (rho_a
                                                       * lambda_a
-                                                      * dpca_dSa + kappa_tilde_a)
+                                                      * dpca_dSa + Kappa_tilde_a)
                                                      * kappa
                                                      * Sa_grad_n
                                                      * normals[point]
                                                      * fe_face.shape_value(i, point)
                                                      * JxW[point];
-
                             copy_data.cell_rhs(i) -= theta_Sa
-                                                     *(-kappa_tilde_a)
+                                                     *(-Kappa_tilde_a)
                                                      * kappa
                                                      * fe_face.shape_grad(i, point)
                                                      * normals[point]
@@ -1130,8 +1088,7 @@ namespace AqueousSaturation
 
                         // Gravity
                         if(!project_Darcy_with_gravity)
-                            copy_data.cell_rhs(i) -= kappa*rho_a_fcn.value(pl_value)
-                                                     * rho_a * lambda_a
+                            copy_data.cell_rhs(i) -= kappa*rho_a_fcn.value(pl_value)*rho_a*lambda_a
                                                      * gravity_fcn.vector_value(q_points[point])
                                                      * normals[point]
                                                      * fe_face.shape_value(i, point)
@@ -1157,8 +1114,10 @@ namespace AqueousSaturation
                     if(use_exact_pl_in_Sa)
                     {
                         pl_fcn.set_time(time);
+
                         pl_value = pl_fcn.value(q_points[point]);
                         pl_grad = pl_fcn.gradient(q_points[point]);
+
                     }
 
                     double Sa_value_n = old_Sa_vals[point];
@@ -1171,9 +1130,11 @@ namespace AqueousSaturation
                     if(use_exact_Sv_in_Sa)
                     {
                         Sv_fcn.set_time(time - time_step);
+
                         Sv_value_n = Sv_fcn.value(q_points[point]);
 
                         Sv_fcn.set_time(time - 2.0*time_step);
+
                         Sv_value_nminus1 = Sv_fcn.value(q_points[point]);
                     }
 
@@ -1188,15 +1149,14 @@ namespace AqueousSaturation
 
                         Sv_nplus1_extrapolation *= 2.0;
                         Sv_nplus1_extrapolation -= Sv_value_nminus1;
+
                     }
 
                     Tensor<1,dim> neumann_term = neumann_fcn.vector_value(q_points[point]);
                     Tensor<1,dim> totalDarcyVelo = DarcyVelocities[point];
 
                     double rho_l = rho_l_fcn.value(pl_value);
-                    double rho_v = rho_v_fcn.value(pl_value,
-                                                   Sa_nplus1_extrapolation,
-                                                   Sv_nplus1_extrapolation);
+                    double rho_v = rho_v_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
                     double rho_a = rho_a_fcn.value(pl_value);
 
                     if(incompressible)
@@ -1204,20 +1164,17 @@ namespace AqueousSaturation
                         rho_l = rho_v = rho_a = 1.0;
                     }
 
-                    double lambda_l = lambda_l_fcn.value(pl_value,
-                                                         Sa_nplus1_extrapolation,
-                                                         Sv_nplus1_extrapolation);
-                    double lambda_v = lambda_v_fcn.value(pl_value,
-                                                         Sa_nplus1_extrapolation,
-                                                         Sv_nplus1_extrapolation);
-                    double lambda_a = lambda_a_fcn.value(pl_value,
-                                                         Sa_nplus1_extrapolation,
-                                                         Sv_nplus1_extrapolation);
+                    double lambda_l = lambda_l_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
+                    double lambda_v = lambda_v_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
+                    double lambda_a = lambda_a_fcn.value(pl_value, Sa_nplus1_extrapolation, Sv_nplus1_extrapolation);
 
                     double rholambda_t = rho_l*lambda_l + rho_v*lambda_v + rho_a*lambda_a;
 
                     for (unsigned int i = 0; i < n_facet_dofs; ++i)
                     {
+
+//					if(cell->face(face_no)->boundary_id() == 5 || cell->face(face_no)->boundary_id() == 6)
+//					{
                         if(project_only_kappa)
                             copy_data.cell_rhs(i) -= (rho_a*lambda_a)
                                                      * totalDarcyVelo
@@ -1230,6 +1187,7 @@ namespace AqueousSaturation
                                                      * normals[point]
                                                      * fe_face.shape_value(i, point)
                                                      * JxW[point];
+//					}
 
                         copy_data.cell_rhs(i) += neumann_term
                                                  * normals[point]
@@ -1238,6 +1196,8 @@ namespace AqueousSaturation
                     }
                 }
             }
+
+
         };
 
         // Interior faces integrals
@@ -1265,9 +1225,7 @@ namespace AqueousSaturation
             const unsigned int n_dofs        = fe_iv.n_current_interface_dofs();
             copy_data_face.joint_dof_indices = fe_iv.get_interface_dof_indices();
 
-            if (rebuild_matrix)
             copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);
-
             copy_data_face.cell_rhs.reinit(n_dofs);
 
             const std::vector<double> &        JxW     = fe_iv.get_JxW_values();
@@ -1282,13 +1240,9 @@ namespace AqueousSaturation
                                                          update_values);
 
             typename DoFHandler<dim>::cell_iterator cell_RT(&triangulation,
-                                                            cell->level(),
-                                                            cell->index(),
-                                                            &dof_handler_RT);
+                                                            cell->level(), cell->index(), &dof_handler_RT);
             typename DoFHandler<dim>::cell_iterator cell_RT_neighbor(&triangulation,
-                                                                     ncell->level(),
-                                                                     ncell->index(),
-                                                                     &dof_handler_RT);
+                                                                     ncell->level(), ncell->index(), &dof_handler_RT);
 
             fe_face_values_RT.reinit(cell_RT, f);
             fe_face_values_RT_neighbor.reinit(cell_RT_neighbor, nf);
@@ -1323,48 +1277,31 @@ namespace AqueousSaturation
             fe_face_neighbor.get_function_values(temp_pl_solution, pl_vals_neighbor);
 
             fe_face.get_function_gradients(temp_pl_solution, pl_grads);
-            fe_face_neighbor.get_function_gradients(temp_pl_solution,
-                                                    pl_grads_neighbor);
-
-            fe_face.get_function_values(temp_Sa_solution_n,
-                                        old_Sa_vals);
-            fe_face.get_function_values(temp_Sa_solution_nminus1,
-                                        old_Sa_vals_nminus1);
-            fe_face.get_function_gradients(temp_Sa_solution_n,
-                                           old_Sa_grads);
-
-            fe_face_neighbor.get_function_values(temp_Sa_solution_n,
-                                                 old_Sa_vals_neighbor);
-            fe_face_neighbor.get_function_values(temp_Sa_solution_nminus1,
-                                                 old_Sa_vals_nminus1_neighbor);
-            fe_face_neighbor.get_function_gradients(temp_Sa_solution_n,
-                                                    old_Sa_grads_neighbor);
-
-            fe_face.get_function_values(temp_Sv_solution_n,
-                                        old_Sv_vals);
-            fe_face.get_function_values(temp_Sv_solution_nminus1,
-                                        old_Sv_vals_nminus1);
-            fe_face.get_function_gradients(temp_Sv_solution_n,
-                                           old_Sv_grads);
-            fe_face.get_function_gradients(temp_Sv_solution_nminus1,
-                                           old_Sv_grads_nminus1);
-
-            fe_face_neighbor.get_function_values(temp_Sv_solution_n,
-                                                 old_Sv_vals_neighbor);
-            fe_face_neighbor.get_function_values(temp_Sv_solution_nminus1,
-                                                 old_Sv_vals_nminus1_neighbor);
-            fe_face_neighbor.get_function_gradients(temp_Sv_solution_n,
-                                                    old_Sv_grads_neighbor);
-            fe_face_neighbor.get_function_gradients(temp_Sv_solution_nminus1,
-                                                    old_Sv_grads_nminus1_neighbor);
+            fe_face_neighbor.get_function_gradients(temp_pl_solution, pl_grads_neighbor);
+
+            fe_face.get_function_values(temp_Sa_solution_n, old_Sa_vals);
+            fe_face.get_function_values(temp_Sa_solution_nminus1, old_Sa_vals_nminus1);
+            fe_face.get_function_gradients(temp_Sa_solution_n, old_Sa_grads);
+
+            fe_face_neighbor.get_function_values(temp_Sa_solution_n, old_Sa_vals_neighbor);
+            fe_face_neighbor.get_function_values(temp_Sa_solution_nminus1, old_Sa_vals_nminus1_neighbor);
+            fe_face_neighbor.get_function_gradients(temp_Sa_solution_n, old_Sa_grads_neighbor);
+
+            fe_face.get_function_values(temp_Sv_solution_n, old_Sv_vals);
+            fe_face.get_function_values(temp_Sv_solution_nminus1, old_Sv_vals_nminus1);
+            fe_face.get_function_gradients(temp_Sv_solution_n, old_Sv_grads);
+            fe_face.get_function_gradients(temp_Sv_solution_nminus1, old_Sv_grads_nminus1);
+
+            fe_face_neighbor.get_function_values(temp_Sv_solution_n, old_Sv_vals_neighbor);
+            fe_face_neighbor.get_function_values(temp_Sv_solution_nminus1, old_Sv_vals_nminus1_neighbor);
+            fe_face_neighbor.get_function_gradients(temp_Sv_solution_n, old_Sv_grads_neighbor);
+            fe_face_neighbor.get_function_gradients(temp_Sv_solution_nminus1, old_Sv_grads_nminus1_neighbor);
 
             std::vector<Tensor<1, dim>> DarcyVelocities(n_qpoints);
-            fe_face_values_RT[velocities].get_function_values(temp_totalDarcyVelocity_RT,
-                                                              DarcyVelocities);
+            fe_face_values_RT[velocities].get_function_values(temp_totalDarcyVelocity_RT, DarcyVelocities);
 
             std::vector<Tensor<1, dim>> DarcyVelocities_neighbor(n_qpoints);
-            fe_face_values_RT_neighbor[velocities].get_function_values(temp_totalDarcyVelocity_RT,
-                                                                       DarcyVelocities_neighbor);
+            fe_face_values_RT_neighbor[velocities].get_function_values(temp_totalDarcyVelocity_RT, DarcyVelocities_neighbor);
 
             // get maximum of Darcy Velocity
             std::vector<double> linf_norm_Darcy_vel0(n_qpoints);
@@ -1383,15 +1320,11 @@ namespace AqueousSaturation
                 linf_norm_Darcy_vel1[kk] = darcy_v1.linfty_norm();
             }
 
-            double maximum_Darcy0 = *std::max_element(linf_norm_Darcy_vel0.begin(),
-                                                      linf_norm_Darcy_vel0.end());
-            double maximum_Darcy1 = *std::max_element(linf_norm_Darcy_vel1.begin(),
-                                                      linf_norm_Darcy_vel1.end());
+            double maximum_Darcy0 = *std::max_element(linf_norm_Darcy_vel0.begin(), linf_norm_Darcy_vel0.end());
+            double maximum_Darcy1 = *std::max_element(linf_norm_Darcy_vel1.begin(), linf_norm_Darcy_vel1.end());
 
-            double maximum_Sa0 = *std::max_element(old_Sa_vals.begin(),
-                                                   old_Sa_vals.end());
-            double maximum_Sa1 = *std::max_element(old_Sa_vals_neighbor.begin(),
-                                                   old_Sa_vals_neighbor.end());
+            double maximum_Sa0 = *std::max_element(old_Sa_vals.begin(), old_Sa_vals.end());
+            double maximum_Sa1 = *std::max_element(old_Sa_vals_neighbor.begin(), old_Sa_vals_neighbor.end());
 
             double kappa0 = temp_kappa[cell->global_active_cell_index()];
             double kappa1 = temp_kappa[ncell->global_active_cell_index()];
@@ -1492,12 +1425,8 @@ namespace AqueousSaturation
                 double rho_l0 = rho_l_fcn.value(pl_value0);
                 double rho_l1 = rho_l_fcn.value(pl_value1);
 
-                double rho_v0 = rho_v_fcn.value(pl_value0,
-                                                Sa_nplus1_extrapolation0,
-                                                Sv_nplus1_extrapolation0);
-                double rho_v1 = rho_v_fcn.value(pl_value1,
-                                                Sa_nplus1_extrapolation1,
-                                                Sv_nplus1_extrapolation1);
+                double rho_v0 = rho_v_fcn.value(pl_value0, Sa_nplus1_extrapolation0, Sv_nplus1_extrapolation0);
+                double rho_v1 = rho_v_fcn.value(pl_value1, Sa_nplus1_extrapolation1, Sv_nplus1_extrapolation1);
 
                 double rho_a0 = rho_a_fcn.value(pl_value0);
                 double rho_a1 = rho_a_fcn.value(pl_value1);
@@ -1508,48 +1437,30 @@ namespace AqueousSaturation
                     rho_l1 = rho_v1 = rho_a1 = 1.0;
                 }
 
-                double lambda_l0 = lambda_l_fcn.value(pl_value0,
-                                                      Sa_nplus1_extrapolation0,
-                                                      Sv_nplus1_extrapolation0);
-                double lambda_v0 = lambda_v_fcn.value(pl_value0,
-                                                      Sa_nplus1_extrapolation0,
-                                                      Sv_nplus1_extrapolation0);
-                double lambda_a0 = lambda_a_fcn.value(pl_value0,
-                                                      Sa_nplus1_extrapolation0,
-                                                      Sv_nplus1_extrapolation0);
-
-                double lambda_l1 = lambda_l_fcn.value(pl_value1,
-                                                      Sa_nplus1_extrapolation1,
-                                                      Sv_nplus1_extrapolation1);
-                double lambda_v1 = lambda_v_fcn.value(pl_value1,
-                                                      Sa_nplus1_extrapolation1,
-                                                      Sv_nplus1_extrapolation1);
-                double lambda_a1 = lambda_a_fcn.value(pl_value1,
-                                                      Sa_nplus1_extrapolation1,
-                                                      Sv_nplus1_extrapolation1);
+                double lambda_l0 = lambda_l_fcn.value(pl_value0, Sa_nplus1_extrapolation0, Sv_nplus1_extrapolation0);
+                double lambda_v0 = lambda_v_fcn.value(pl_value0, Sa_nplus1_extrapolation0, Sv_nplus1_extrapolation0);
+                double lambda_a0 = lambda_a_fcn.value(pl_value0, Sa_nplus1_extrapolation0, Sv_nplus1_extrapolation0);
+
+                double lambda_l1 = lambda_l_fcn.value(pl_value1, Sa_nplus1_extrapolation1, Sv_nplus1_extrapolation1);
+                double lambda_v1 = lambda_v_fcn.value(pl_value1, Sa_nplus1_extrapolation1, Sv_nplus1_extrapolation1);
+                double lambda_a1 = lambda_a_fcn.value(pl_value1, Sa_nplus1_extrapolation1, Sv_nplus1_extrapolation1);
 
                 double rholambda_t0 = rho_l0*lambda_l0 + rho_v0*lambda_v0 + rho_a0*lambda_a0;
                 double rholambda_t1 = rho_l1*lambda_l1 + rho_v1*lambda_v1 + rho_a1*lambda_a1;
 
-                double dpca_dSa0 = cap_p_pca_fcn.derivative_wrt_Sa(Sa_nplus1_extrapolation0,
-                                                                   Sv_nplus1_extrapolation0);
-                double dpca_dSa1 = cap_p_pca_fcn.derivative_wrt_Sa(Sa_nplus1_extrapolation1,
-                                                                   Sv_nplus1_extrapolation1);
+                double dpca_dSa0 = cap_p_pca_fcn.derivative_wrt_Sa(Sa_nplus1_extrapolation0, Sv_nplus1_extrapolation0);
+                double dpca_dSa1 = cap_p_pca_fcn.derivative_wrt_Sa(Sa_nplus1_extrapolation1, Sv_nplus1_extrapolation1);
 
-                double dpca_dSv0 = cap_p_pca_fcn.derivative_wrt_Sv(Sa_nplus1_extrapolation0,
-                                                                   Sv_nplus1_extrapolation0);
-                double dpca_dSv1 = cap_p_pca_fcn.derivative_wrt_Sv(Sa_nplus1_extrapolation1,
-                                                                   Sv_nplus1_extrapolation1);
+                double dpca_dSv0 = cap_p_pca_fcn.derivative_wrt_Sv(Sa_nplus1_extrapolation0, Sv_nplus1_extrapolation0);
+                double dpca_dSv1 = cap_p_pca_fcn.derivative_wrt_Sv(Sa_nplus1_extrapolation1, Sv_nplus1_extrapolation1);
 
                 double nu_h_artificial_visc0 = 0.0;
                 double nu_h_artificial_visc1 = 0.0;
 
                 if(artificial_visc_exp || artificial_visc_imp)
                 {
-                    nu_h_artificial_visc0 = 0.5*sqrt(cell->measure())
-                                            *art_visc_multiple_Sa*maximum_Darcy0*2.0*maximum_Sa0;
-                    nu_h_artificial_visc1 = 0.5*sqrt(ncell->measure())
-                                            *art_visc_multiple_Sa*maximum_Darcy1*2.0*maximum_Sa1;
+                    nu_h_artificial_visc0 = 0.5*sqrt(cell->measure())*art_visc_multiple_Sa*maximum_Darcy0*2.0*maximum_Sa0;
+                    nu_h_artificial_visc1 = 0.5*sqrt(ncell->measure())*art_visc_multiple_Sa*maximum_Darcy1*2.0*maximum_Sa1;
                 }
 
                 // Diffusion coefficients and weights for stab method
@@ -1557,8 +1468,8 @@ namespace AqueousSaturation
                 double coef1_diff = fabs(rho_a1*lambda_a1*kappa1*dpca_dSa1);
 
                 // for stabilization term
-                double coef0_diff_stab = fabs(kappa0*kappa_tilde_a);
-                double coef1_diff_stab = fabs(kappa1*kappa_tilde_a);
+                double coef0_diff_stab = fabs(kappa0*Kappa_tilde_a);
+                double coef1_diff_stab = fabs(kappa1*Kappa_tilde_a);
 
                 if(artificial_visc_imp)
                 {
@@ -1596,12 +1507,16 @@ namespace AqueousSaturation
                 double weight1_Sv = coef0_Sv/(coef0_Sv + coef1_Sv + 1.e-20);
 
                 //Sa coefficients and weights for stab method
-                double coef0_Sa_stab = (rho_a0*lambda_a0*dpca_dSa0+kappa_tilde_a)*kappa0;
-                double coef1_Sa_stab = (rho_a1*lambda_a1*dpca_dSa1+kappa_tilde_a)*kappa1;
+                double coef0_Sa_stab = (rho_a0*lambda_a0*dpca_dSa0+Kappa_tilde_a)*kappa0;
+                double coef1_Sa_stab = (rho_a1*lambda_a1*dpca_dSa1+Kappa_tilde_a)*kappa1;
+                //TEST DEBUG LC --> BAD
+                //double coef0_Sa_stab = fabs(rho_a0*lambda_a0*dpca_dSa0+Kappa_tilde_a)*kappa0;
+                //double coef1_Sa_stab = fabs(rho_a1*lambda_a1*dpca_dSa1+Kappa_tilde_a)*kappa1;
 
                 double weight0_Sa_stab = coef1_Sa_stab/(coef0_Sa_stab + coef1_Sa_stab + 1.e-20);
                 double weight1_Sa_stab = coef0_Sa_stab/(coef0_Sa_stab + coef1_Sa_stab + 1.e-20);
 
+
                 // start of interior face terms
                 for (unsigned int i = 0; i < n_dofs; ++i)
                 {
@@ -1617,31 +1532,22 @@ namespace AqueousSaturation
                                 * JxW[point];
                             if (Stab_a)
                             {
-                                double weighted_aver_j_stab =
-                                        AverageGradOperators::weighted_average_gradient<dim>(cell, f, sf,
-                                                                                             ncell, nf,
+                                double weighted_aver_j_stab = AverageGradOperators::weighted_average_gradient<dim>(cell, f, sf, ncell, nf,
                                                                                                                nsf, fe_iv,
                                                                                                                normals[point],
                                                                                                                j, point,
-                                                                                             coef0_diff_stab,
-                                                                                             coef1_diff_stab,
-                                                                                             weight0_diff_stab,
-                                                                                             weight1_diff_stab);
+                                                                                                               coef0_diff_stab, coef1_diff_stab,
+                                                                                                               weight0_diff_stab, weight1_diff_stab);
                                 copy_data_face.cell_matrix(i, j) -=
                                     fe_iv.jump_in_shape_values(i, point)
                                     * weighted_aver_j_stab
                                     * JxW[point];
-
-                                double weighted_aver_i_stab =
-                                        AverageGradOperators::weighted_average_gradient<dim>(cell, f, sf,
-                                                                                             ncell, nf,
+                                double weighted_aver_i_stab = AverageGradOperators::weighted_average_gradient<dim>(cell, f, sf, ncell, nf,
                                                                                                                nsf, fe_iv,
                                                                                                                normals[point],
                                                                                                                i, point,
-                                                                                             coef0_diff_stab,
-                                                                                             coef1_diff_stab,
-                                                                                             weight0_diff_stab,
-                                                                                             weight1_diff_stab);
+                                                                                                               coef0_diff_stab, coef1_diff_stab,
+                                                                                                               weight0_diff_stab, weight1_diff_stab);
                                 copy_data_face.cell_matrix(i, j) +=
                                     theta_Sa
                                     * fe_iv.jump_in_shape_values(j, point)
@@ -1650,30 +1556,22 @@ namespace AqueousSaturation
                             }
                             else
                             {
-                                double weighted_aver_j =
-                                        AverageGradOperators::weighted_average_gradient<dim>(cell, f, sf,
-                                                                                             ncell, nf,
+                                double weighted_aver_j = AverageGradOperators::weighted_average_gradient<dim>(cell, f, sf, ncell, nf,
                                                                                                           nsf, fe_iv,
                                                                                                           normals[point],
                                                                                                           j, point,
-                                                                                             coef0_diff,
-                                                                                             coef1_diff,
-                                                                                             weight0_diff,
-                                                                                             weight1_diff);
+                                                                                                          coef0_diff, coef1_diff,
+                                                                                                          weight0_diff, weight1_diff);
                                 copy_data_face.cell_matrix(i, j) -=
                                     fe_iv.jump_in_shape_values(i, point)
                                     * weighted_aver_j
                                     * JxW[point];
-                                double weighted_aver_i =
-                                        AverageGradOperators::weighted_average_gradient<dim>(cell, f, sf,
-                                                                                             ncell, nf,
+                                double weighted_aver_i = AverageGradOperators::weighted_average_gradient<dim>(cell, f, sf, ncell, nf,
                                                                                                           nsf, fe_iv,
                                                                                                           normals[point],
                                                                                                           i, point,
-                                                                                             coef0_diff,
-                                                                                             coef1_diff,
-                                                                                             weight0_diff,
-                                                                                             weight1_diff);
+                                                                                                          coef0_diff, coef1_diff,
+                                                                                                          weight0_diff, weight1_diff);
                                 copy_data_face.cell_matrix(i, j) +=
                                     theta_Sa
                                     * fe_iv.jump_in_shape_values(j, point)
@@ -1686,14 +1584,10 @@ namespace AqueousSaturation
                     if(Stab_a)
                     {
                         // Sa term added to the RHS
-                        double weighted_aver_rhs0_stab =
-                                AverageGradOperators::weighted_average_rhs<dim>(normals[point],
-                                                                                Sa_grad0_n,
-                                                                                Sa_grad1_n,
-                                                                                coef0_Sa_stab,
-                                                                                coef1_Sa_stab,
-                                                                                weight0_Sa_stab,
-                                                                                weight1_Sa_stab);
+                        double weighted_aver_rhs0_stab = AverageGradOperators::weighted_average_rhs<dim>(normals[point],
+                                                                                                         Sa_grad0_n, Sa_grad1_n,
+                                                                                                         coef0_Sa_stab, coef1_Sa_stab,
+                                                                                                         weight0_Sa_stab, weight1_Sa_stab);
 
                         copy_data_face.cell_rhs(i) -=
                                 weighted_aver_rhs0_stab
@@ -1701,14 +1595,10 @@ namespace AqueousSaturation
                                 * JxW[point];
                     }
                     // Sv term added to RHS
-                    double weighted_aver_rhs1 =
-                            AverageGradOperators::weighted_average_rhs<dim>(normals[point],
-                                                                            Sv_grad_nplus1_extrapolation0,
-                                                                            Sv_grad_nplus1_extrapolation1,
-                                                                            coef0_Sv,
-                                                                            coef1_Sv,
-                                                                            weight0_Sv,
-                                                                            weight1_Sv);
+                    double weighted_aver_rhs1 = AverageGradOperators::weighted_average_rhs<dim>(normals[point],
+                                                                                                Sv_grad_nplus1_extrapolation0, Sv_grad_nplus1_extrapolation1,
+                                                                                                coef0_Sv, coef1_Sv,
+                                                                                                weight0_Sv, weight1_Sv);
                     copy_data_face.cell_rhs(i) -=
                             weighted_aver_rhs1
                             * fe_iv.jump_in_shape_values(i, point)
@@ -1765,8 +1655,8 @@ namespace AqueousSaturation
 
                         double weight0_g = coef1_g/(coef0_g + coef1_g + 1.e-20);
                         double weight1_g = coef0_g/(coef0_g + coef1_g + 1.e-20);
-                        double weighted_aver_rhs3 =
-                                AverageGradOperators::weighted_average_rhs(normals[point],
+
+                        double weighted_aver_rhs3 = AverageGradOperators::weighted_average_rhs(normals[point],
                                                                                                g_val, g_val,
                                                                                                coef0_g, coef1_g,
                                                                                                weight0_g, weight1_g);
@@ -1785,8 +1675,7 @@ namespace AqueousSaturation
                         double weight0_nu = coef1_nu/(coef0_nu + coef1_nu + 1.e-20);
                         double weight1_nu = coef0_nu/(coef0_nu + coef1_nu + 1.e-20);
 
-                        double weighted_aver_rhs_nu =
-                                AverageGradOperators::weighted_average_rhs(normals[point],
+                        double weighted_aver_rhs_nu = AverageGradOperators::weighted_average_rhs(normals[point],
                                                                                                  Sa_grad0_n, Sa_grad1_n,
                                                                                                  coef0_nu, coef1_nu,
                                                                                                  weight0_nu, weight1_nu);
@@ -1795,8 +1684,11 @@ namespace AqueousSaturation
                                                       * fe_iv.jump_in_shape_values(i, point)
                                                       * JxW[point];
                     }
+
+
                 }
             }
+
         };
 
         const auto copier = [&](const CopyData &c) {
@@ -1822,13 +1714,11 @@ namespace AqueousSaturation
                 constraints.distribute_local_to_global(c.cell_rhs,
                                                        c.local_dof_indices,
                                                        right_hand_side_aqueous_saturation);
-
                 for (auto &cdf : c.face_data)
                 {
                     constraints.distribute_local_to_global(cdf.cell_rhs,
                                                            cdf.joint_dof_indices,
                                                            right_hand_side_aqueous_saturation);
-
                 }
             }
         };
@@ -1838,7 +1728,8 @@ namespace AqueousSaturation
         const UpdateFlags cell_flags = update_values | update_gradients |
                                        update_quadrature_points | update_JxW_values;
         const UpdateFlags face_flags = update_values | update_gradients |
-                                       update_quadrature_points | update_normal_vectors | update_JxW_values;
+                                       update_quadrature_points |
+                                       update_normal_vectors | update_JxW_values;
 
         ScratchData scratch_data(mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);
         CopyData         copy_data;
@@ -1863,18 +1754,23 @@ namespace AqueousSaturation
         {
             system_matrix_aqueous_saturation.compress(VectorOperation::add);
         }
-        // testing to see if matrix changes at every time step
-	    //pcout << system_matrix_aqueous_saturation.frobenius_norm() << std::endl;
 
         right_hand_side_aqueous_saturation.compress(VectorOperation::add);
     }
 
     template <int dim>
-    void AqueousSaturationProblem<dim>::solve_aqueous_saturation(const PETScWrappers::MPI::Vector& pl_solution_)
+    void AqueousSaturationProblem<dim>::solve_aqueous_saturation( PETScWrappers::MPI::Vector pl_solution_)
     {
-        // reinit vector solution
         Sa_solution.reinit(locally_owned_dofs, mpi_communicator);
 
+//	std::map<types::global_dof_index, double> boundary_values;
+//	        VectorTools::interpolate_boundary_values(dof_handler,
+//	                                                 1,
+//													 BoundaryValuesAqueousSaturation<dim>(),
+//	                                                 boundary_values);
+//		MatrixTools::apply_boundary_values(
+//	          boundary_values, system_matrix_aqueous_saturation, Sa_solution, right_hand_side_aqueous_saturation, false);
+
         if(use_direct_solver)
         {
             SolverControl cn;

diff --git a/Q5S/Auxiliary_Functions_PrimaryVars.cc b/Auxiliary_Functions_PrimaryVars.cc
index 0fb6c98..ac17032 100644
--- a/Q5S/Auxiliary_Functions_PrimaryVars.cc
+++ b/Auxiliary_Functions_PrimaryVars.cc
@@ -25,9 +25,6 @@ using namespace dealii;
 double amp_factor_cap_pressure = 1.e7;
 double kappa = 1.0;
 
-// stability terms
-double kappa_tilde_a_data = 5.0;
-double kappa_tilde_v_data = 5.0;
 // Mesh creator
 template <int dim>
 void create_mesh(Triangulation<dim, dim> &triangulation, unsigned int ref_level,
@@ -35,128 +32,59 @@ void create_mesh(Triangulation<dim, dim> &triangulation, unsigned int ref_level,
 		std::vector<unsigned int> &dirichlet_id_sa,
 		std::vector<unsigned int> &dirichlet_id_sv)
 {
-//	Triangulation<dim> triangulation1;
-//
-//	Point<dim> v0;
-//	Point<dim> v1;
-//
-//	// bottom left corner of the domain
-//	v0[0] = 5.0;
-//	v0[1] = 0.0;
-//
-//	// top right corner of the domain
-//	v1[0] = 95.0;
-//	v1[1] = 100.0;
-//
-//	std::vector<unsigned int> repetitions(dim);
-//
-//	repetitions[0] = 18;
-//	repetitions[1] = 20;
-//
-//	GridGenerator::subdivided_hyper_rectangle(triangulation1, repetitions, v0, v1);
-//
-//	Triangulation<dim> triangulation2;
-//
-//	// bottom left corner of the domain
-//	v0[0] = 0.0;
-//	v0[1] = 5.0;
-//
-//	// top right corner of the domain
-//	v1[0] = 5.0;
-//	v1[1] = 100.0;
-//
-//	repetitions[0] = 1;
-//	repetitions[1] = 19;
-//
-//	GridGenerator::subdivided_hyper_rectangle(triangulation2, repetitions, v0, v1);
-//
-//	Triangulation<dim> triangulation3;
-//
-//	// bottom left corner of the domain
-//	v0[0] = 95.0;
-//	v0[1] = 0.0;
-//
-//	// top right corner of the domain
-//	v1[0] = 100.0;
-//	v1[1] = 95.0;
-//
-//	repetitions[0] = 1;
-//	repetitions[1] = 19;
-//
-//	GridGenerator::subdivided_hyper_rectangle(triangulation3, repetitions, v0, v1);
-//
-//	GridGenerator::merge_triangulations	({&triangulation1, &triangulation2, &triangulation3}, triangulation);
-//
-    Triangulation<dim> triangulation1;
-
-    Point<dim> v0;
-    Point<dim> v1;
-
-    v0[0] = 0.0;
-    v0[1] = 0.0;
+	Triangulation<dim> triangulation1;
 
-    if(dim == 3)
-        v0[2] = 0.0;
+	Point<dim> v0;
+	Point<dim> v1;
 
-    v1[0] = 50.0;
-    v1[1] = 100.0;
+	// bottom left corner of the domain
+	v0[0] = 5.0;
+	v0[1] = 0.0;
 
-    if(dim == 3)
-        v1[2] = 100.0;
+	// top right corner of the domain
+	v1[0] = 95.0;
+	v1[1] = 100.0;
 
-    std::vector<unsigned int> repetitions(dim);
-    repetitions[0] = 10;
-    repetitions[1] = 20;
+	std::vector<unsigned int> repetitions(dim);
 
-    if (dim == 3)
-        repetitions[2] = 20;
+	repetitions[0] = 18;
+	repetitions[1] = 20;
 
-    std::vector<int> n_cells_to_remove(dim);
-    n_cells_to_remove[0] = 1;
-    n_cells_to_remove[1] = 1;
+	GridGenerator::subdivided_hyper_rectangle(triangulation1, repetitions, v0, v1);
 
-    if (dim == 3)
-        n_cells_to_remove[2] = -1;
+	Triangulation<dim> triangulation2;
 
-    GridGenerator::subdivided_hyper_L(triangulation1, repetitions, v0, v1, n_cells_to_remove);
+	// bottom left corner of the domain
+	v0[0] = 0.0;
+	v0[1] = 5.0;
 
-    //*---------------------------------
-    Triangulation<dim> triangulation2;
+	// top right corner of the domain
+	v1[0] = 5.0;
+	v1[1] = 100.0;
 
-    Point<dim> v0_2;
-    Point<dim> v1_2;
+	repetitions[0] = 1;
+	repetitions[1] = 19;
 
-    v0_2[0] = 50.0;
-    v0_2[1] = 0.0;
+	GridGenerator::subdivided_hyper_rectangle(triangulation2, repetitions, v0, v1);
 
-    if (dim == 3)
-        v0_2[2] = 0.0;
+	Triangulation<dim> triangulation3;
 
-    v1_2[0] = 100.0;
-    v1_2[1] = 100.0;
+	// bottom left corner of the domain
+	v0[0] = 95.0;
+	v0[1] = 0.0;
 
-    if (dim == 3)
-        v1_2[2] = 100.0;
+	// top right corner of the domain
+	v1[0] = 100.0;
+	v1[1] = 95.0;
 
-    std::vector<unsigned int> repetitions_2(dim);
-    repetitions_2[0] = 10;
-    repetitions_2[1] = 20;
+	repetitions[0] = 1;
+	repetitions[1] = 19;
 
-    if (dim == 3)
-        repetitions_2[2] = 20;
-
-    std::vector<int> n_cells_to_remove_2(dim);
-
-    n_cells_to_remove_2[0] = -1;
-    n_cells_to_remove_2[1] = -1;
-
-    if (dim == 3)
-        n_cells_to_remove_2[2] = 1;
-
-    GridGenerator::subdivided_hyper_L(triangulation2, repetitions_2, v0_2, v1_2, n_cells_to_remove_2);
-
-    GridGenerator::merge_triangulations({&triangulation1,&triangulation2},triangulation);
+	GridGenerator::subdivided_hyper_rectangle(triangulation3, repetitions, v0, v1);
 
+	GridGenerator::merge_triangulations	({&triangulation1, &triangulation2, &triangulation3}, triangulation);
+	
+	//GridGenerator::hyper_cube(triangulation, 0.0, 1.0);
 	triangulation.refine_global(ref_level);
 
 	// Boundary classification
@@ -173,6 +101,8 @@ void create_mesh(Triangulation<dim, dim> &triangulation, unsigned int ref_level,
 		cell = triangulation.begin_active(),
 		endc = triangulation.end();
 
+
+
 	for (; cell != endc; cell++)
 	{
 		for (unsigned int face_no=0; face_no < GeometryInfo<dim>::faces_per_cell; face_no++)
@@ -367,57 +297,64 @@ double compute_kappa_value(const typename DoFHandler<dim>::active_cell_iterator
 {
 //	double kappa_abs = 3.72e-13;
 	double kappa_abs = 5.e-8;
-//	double xx = cell->center()[0];
-//	double yy = cell->center()[1];
-//
-//	double zz;
-//	if(dim == 3){
-//		zz = cell->center()[2];
-//	}
-//
-//
-//	if(xx >= 25.0 && xx <= 50.0)
-//		if((yy >= 25.0 && yy <= 50.0))
-//			kappa_abs /= 1000.0;
-	return kappa_abs;
+	// double xx = cell->center()[0];
+	// double yy = cell->center()[1];
+
+	// double zz;
+	// if(dim == 3){
+	// 	zz = cell->center()[2];
+	// }
+
+
+	// if(xx >= 25.0 && xx <= 50.0)
+	// 	if((yy >= 25.0 && yy <= 50.0))
+	// 		kappa_abs /= 1000.0;
+	// return kappa_abs;
 };
 
 
 
 template <int dim>
-class StabAqueousSaturation : public Function<dim>
+class Kappa_tilde_a : public Function<dim>
 {
 public:
-    StabAqueousSaturation()
+    Kappa_tilde_a()
             : Function<dim>(1)
-    {}
+    {} 
 
     virtual double value() const;
 };
+
 template <int dim>
-double StabAqueousSaturation<dim>::value()const
+double Kappa_tilde_a<dim>::value()const
 {
-
-    return kappa_tilde_a_data;
+    //return 1000.0; 
+    //return 200.0; 
+    //return 5.0; 
+    return 5.0;
 }
 
+
 template <int dim>
-class StabVaporSaturation : public Function<dim>
+class Kappa_tilde_v : public Function<dim>
 {
 public:
-    StabVaporSaturation()
+    Kappa_tilde_v()
             : Function<dim>(1)
     {}
 
     virtual double value() const;
 };
+
 template <int dim>
-double StabVaporSaturation<dim>::value()const
+double Kappa_tilde_v<dim>::value()const
 {
-    return kappa_tilde_v_data;
+    //return 1000.0;
+    //return 200.0;
+    //return 5.0; 
+    return 1.0;
 }
 
-
 template <int dim>
 class ExactLiquidPressure : public Function<dim>
 {
